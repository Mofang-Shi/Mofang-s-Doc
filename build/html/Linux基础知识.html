<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linux基础 &mdash; Mofang&#39;s Docs v0.0 文档</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=c57d4d51"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="_static/translations.js?v=beaddf03"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="关于此文档" href="about.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Makefile基础" href="Makefile%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" />
    <link rel="prev" title="git&amp;gh教程" href="git%E4%B8%8Egh%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Mofang's Docs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">旧的内容</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="reStructureText%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8.html">reStructureText语法入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="git%E4%B8%8Egh%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">git&amp;gh教程</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linux基础</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shell">一、“Shell”是什么?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#terminal">在终端（Terminal）键入/使用鼠标</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#navigation">二、导航（Navigation）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pwd"><code class="docutils literal notranslate"><span class="pre">pwd</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ls"><code class="docutils literal notranslate"><span class="pre">ls</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cd"><code class="docutils literal notranslate"><span class="pre">cd</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">关于文件名的重要事实</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#looking-around">三、浏览（Looking Around）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">ls</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#long-format">关于长格式（Long Format）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#less"><code class="docutils literal notranslate"><span class="pre">less</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#file"><code class="docutils literal notranslate"><span class="pre">file</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linux-a-guided-tour">四、一次Linux旅行（A Guided Tour）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">我的Linux旅行</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#manipulating-files">五、操作文件（Manipulating Files）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#wildcards">通配符（Wildcards）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cp"><code class="docutils literal notranslate"><span class="pre">cp</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#mv"><code class="docutils literal notranslate"><span class="pre">mv</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rm"><code class="docutils literal notranslate"><span class="pre">rm</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">谨慎使用<code class="docutils literal notranslate"><span class="pre">rm</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#mkdir"><code class="docutils literal notranslate"><span class="pre">mkdir</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">使用带有通配符的命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-commands">六、使用命令工作（Working with Commands）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">什么是“命令”？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type">识别命令——<code class="docutils literal notranslate"><span class="pre">type</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#which">识别命令——<code class="docutils literal notranslate"><span class="pre">which</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#help">命令文档——<code class="docutils literal notranslate"><span class="pre">help</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#man">正式文档——<code class="docutils literal notranslate"><span class="pre">man</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#readme">README和其他文档文件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#i-o-i-o-redirection">七、I/O重定向（I/O Redirection）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">标准输出</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">标准输入</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pipelines">管道（Pipelines）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filters">过滤器（Filters）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">一些例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#expansion">八、扩展（Expansion）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">路径名扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tilde-expansion">Tilde Expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">算术拓展</a></li>
<li class="toctree-l3"><a class="reference internal" href="#brace-expansion">Brace Expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-expansion">参数扩展（Parameter Expansion）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#command-substitution">命令替换（Command Substitution）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quoting">引用（Quoting）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#escaping-characters">转义字符（Escaping Characters）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#backslash-tricks">反斜线技巧（Backslash Tricks）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#permissions">九、权限（Permissions）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#file-permissions">文件权限（File Permissions）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#chmod"><code class="docutils literal notranslate"><span class="pre">chmod</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#directory-permissions">目录权限（Directory Permissions）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#becoming-the-superuser-for-a-short-while">暂时成为超级用户（Becoming the Superuser for a Short While）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#changing-file-ownership">更改文件所有权（Changing File Ownership）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#changing-group-ownership">改变组的所有权（Changing Group Ownership）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#job-control">十、控制工作（Job Control）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">一个实例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#putting-a-program-into-the-background">将程序放入后台（Putting a Program into the Background）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#listing-running-processes">列出正在运行的进程（Listing Running Processes）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#killing-a-process">杀死进程（Killing a Process）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kill">关于<code class="docutils literal notranslate"><span class="pre">kill</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id14">十一、比较文件</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Makefile%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">Makefile基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">正则表达式教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="Vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.html">Vim编辑器基础教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%89%8B%E6%90%93%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html">Python手搓神经网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html">关于</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">论文复现</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/%E9%81%A5%E6%84%9F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86.html">(TGRS, 2022) 遥感图像处理</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Mofang's Docs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Linux基础</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Linux基础知识.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="linux">
<h1>Linux基础<a class="headerlink" href="#linux" title="Link to this heading"></a></h1>
<section id="id1">
<h2>介绍<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>本教程来自<code class="docutils literal notranslate"><span class="pre">UCB</span> <span class="pre">EECS151</span> <span class="pre">ASIC</span> <span class="pre">Lab1</span></code>推荐阅读的教程：Learning the Shell：<a class="reference external" href="http://linuxcommand.org/lc3_learning_the_shell.php">Learning the Shell</a></p>
</section>
<section id="shell">
<h2>一、“Shell”是什么?<a class="headerlink" href="#shell" title="Link to this heading"></a></h2>
<p>简而言之，Shell是一个<strong>从键盘上获取命令并将其交给操作系统执行的程序</strong>。在过去，它是Linux等类Unix系统上唯一可用的用户界面。如今，除了Shell等命令行界面（command line interfaces，CLI）外，我们还有图形用户界面（graphical user interfaces，GUI）。</p>
<p>在大多数Linux系统上，一个名为<code class="docutils literal notranslate"><span class="pre">bash</span></code>的程序（代表Bourne Again SHell，由Steve Bourne编写的原始Unix shell程序sh的增强版本）充当Shell程序。除了bash，还有其他适用于Linux系统的shell程序。这些包括：<code class="docutils literal notranslate"><span class="pre">ksh</span></code>、<code class="docutils literal notranslate"><span class="pre">tcsh</span></code>和<code class="docutils literal notranslate"><span class="pre">zsh</span></code>。</p>
<section id="terminal">
<h3>在终端（Terminal）键入/使用鼠标<a class="headerlink" href="#terminal" title="Link to this heading"></a></h3>
<p>打开一个终端窗口。我们应该看到的第一个东西是一个shell提示，其中包含我们的用户名和机器名称，后跟一个美元符号（$）。如下所示：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>
</pre></div>
</div>
<p><strong>向上箭头键</strong>——上一个命令（Command history）</p>
<p><strong>向下箭头键</strong>——回到空白行</p>
<p><strong>向左/右键</strong>——移动光标</p>
<p><strong>使用鼠标</strong>——复制文本</p>
<p><strong>超级用户（Superuser）</strong>： 如果shell提示符的最后一个字符是<code class="docutils literal notranslate"><span class="pre">#</span></code>而不是<code class="docutils literal notranslate"><span class="pre">$</span></code>，则正在作为超级用户操作。这意味着拥有管理权限，可以删除或覆盖系统上的任何文件。
<strong>除非绝对需要管理权限，否则不要作为超级用户操作！</strong></p>
</section>
</section>
<section id="navigation">
<h2>二、导航（Navigation）<a class="headerlink" href="#navigation" title="Link to this heading"></a></h2>
<p>这个部分将会使用到三个命令：<code class="docutils literal notranslate"><span class="pre">pwd</span></code>打印工作目录、<code class="docutils literal notranslate"><span class="pre">cd</span></code>更改目录、<code class="docutils literal notranslate"><span class="pre">ls</span></code>列表文件和目录</p>
<section id="pwd">
<h3><code class="docutils literal notranslate"><span class="pre">pwd</span></code><a class="headerlink" href="#pwd" title="Link to this heading"></a></h3>
<p>我们所处的目录称为工作目录（Working directory）。要查看工作目录的名称，我们使用pwd命令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">pwd</span>
/home/shimofang
</pre></div>
</div>
<p>当我们第一次登录Linux系统时，工作目录被设置为我们的主目录（home directory）。这就是我们放文件的地方。在大多数系统上，主目录将被称为<code class="docutils literal notranslate"><span class="pre">/home/user_name</span></code>，但根据系统管理员的奇思妙想，它可以是任何东西。</p>
</section>
<section id="ls">
<h3><code class="docutils literal notranslate"><span class="pre">ls</span></code><a class="headerlink" href="#ls" title="Link to this heading"></a></h3>
<p>要列出工作目录中的文件，我们使用ls命令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls
公共的<span class="w">  </span>模板<span class="w">  </span>视频<span class="w">  </span>图片<span class="w">  </span>文档<span class="w">  </span>下载<span class="w">  </span>音乐<span class="w">  </span>桌面<span class="w">  </span>snap
</pre></div>
</div>
</section>
<section id="cd">
<h3><code class="docutils literal notranslate"><span class="pre">cd</span></code><a class="headerlink" href="#cd" title="Link to this heading"></a></h3>
<p>要更改工作目录，我们使用cd命令：
<code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">+</span> <span class="pre">所需工作目录的路径名</span></code></p>
<p>路径名可以指定两种不同的方式：<code class="docutils literal notranslate"><span class="pre">绝对路径名</span></code>或<code class="docutils literal notranslate"><span class="pre">相对路径名</span></code>。</p>
<p><strong>绝对路径名</strong>从根目录开始，并逐个分支跟随树，直到所需目录或文件的路径完成。例如，您的系统上有一个目录，其中安装了大多数程序。目录的路径名是<code class="docutils literal notranslate"><span class="pre">/usr/bin</span></code>。这意味着从根目录（由路径名中的前导斜杠表示）有一个名为“usr”的目录，其中包含一个名为“bin”的目录。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/usr/bin
shimofang@shimofang-virtual-machine:/usr/bin$<span class="w"> </span><span class="nb">pwd</span>
/usr/bin
shimofang@shimofang-virtual-machine:/usr/bin$<span class="w"> </span>ls
<span class="s1">&#39;[&#39;</span><span class="w">                                   </span>mtr-packet
<span class="w"> </span>aa-enabled<span class="w">                           </span>mv
<span class="w"> </span>aa-exec<span class="w">                              </span>namei
<span class="w"> </span>aa-features-abi<span class="w">                      </span>nano
<span class="w"> </span>aconnect<span class="w">                             </span>nautilus
<span class="w"> </span>acpi_listen<span class="w">                          </span>nautilus-autorun-software
<span class="w"> </span>add-apt-repository<span class="w">                   </span>nautilus-sendto
<span class="w"> </span>addpart<span class="w">                              </span>nawk
<span class="w"> </span>airscan-discover<span class="w">                     </span>nc

and<span class="w"> </span>many<span class="w"> </span>more...
</pre></div>
</div>
<p>现在我们可以看到，我们已经将当前工作目录更改为/usr/bin，并且它充满了文件。注意shell提示是如何更改的吗？为了方便起见，它通常设置为<strong>显示工作目录的名称</strong>。</p>
<p><strong>相对路径名</strong>从工作目录开始。为此，它使用几个特殊符号来表示文件系统树中的相对位置。</p>
<p><code class="docutils literal notranslate"><span class="pre">.</span></code>——指工作目录本身、<code class="docutils literal notranslate"><span class="pre">..</span></code>——指工作目录的父目录</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/usr/bin
shimofang@shimofang-virtual-machine:/usr/bin$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>..
shimofang@shimofang-virtual-machine:/usr$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>./bin
shimofang@shimofang-virtual-machine:/usr/bin$<span class="w"> </span>
</pre></div>
</div>
<p><strong>键入cd后不跟任何内容</strong>——cd会将工作目录更改为我们的主目录。</p>
<p><strong>键入cd ~user_name</strong>——cd会将工作目录更改为指定用户的主目录。</p>
<p><strong>键入cd-</strong>——将工作目录更改为上一个目录。</p>
</section>
<section id="id2">
<h3>关于文件名的重要事实<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>1、以句号字符开头的文件名被隐藏。除非我们用<code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">-a</span></code>，否则ls不会列出它们。</p>
<p>2、Linux中的文件名和Unix一样，区分大小写。文件名“File1”和“file1”指的是不同的文件。</p>
<p>3、Linux没有像Windows系统那样的“文件扩展”概念。您可以以任何您喜欢的方式命名文件。但许多应用程序会关心文件扩展名。</p>
<p>4、虽然Linux支持可能包含嵌入式空格和标点符号的长文件名，但将标点符号限制为句号<code class="docutils literal notranslate"><span class="pre">.</span></code>、破折号<code class="docutils literal notranslate"><span class="pre">-</span></code>和下划线<code class="docutils literal notranslate"><span class="pre">_</span></code>。</p>
<p>5、最重要的是，<strong>不要在文件名中嵌入空格</strong>。如果您想表示文件名中单词之间的空格，请使用下划线字符。</p>
</section>
</section>
<section id="looking-around">
<h2>三、浏览（Looking Around）<a class="headerlink" href="#looking-around" title="Link to this heading"></a></h2>
<p>这个部分将会使用到三个命令：<code class="docutils literal notranslate"><span class="pre">ls</span></code>列表文件和目录、<code class="docutils literal notranslate"><span class="pre">less</span></code>查看文本文件、<code class="docutils literal notranslate"><span class="pre">file</span></code>对文件的内容进行分类</p>
<section id="id3">
<h3><code class="docutils literal notranslate"><span class="pre">ls</span></code><a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ls</span></code>命令用于列出目录的内容。这可能是最常用的Linux命令。它可以以多种不同的方式使用。以下是一些例子：
| Command         | Result                                                                                     |
|—————–|——————————————————————————————–|
| ls              | 列出工作目录（working directory）中的文件                                                  |
| ls /bin         | 列出/bin目录（或指定的任何其他目录）中的文件                                               |
| ls -l           | 以长格式（long format）列出工作目录中的文件                                                |
| ls -l /etc /bin | 以长格式列出/bin目录和/etc目录中的文件                                                     |
| ls -la ..       | 以长格式列出工作目录父目录中的所有文件（即使名称以句号字符开头的文件，这些文件通常被隐藏） |</p>
<p>这些例子还指出了关于命令的一个重要概念。大多数命令的操作是这样的：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">command</span><span class="w"> </span>-options<span class="w"> </span>arguments
<span class="w">   </span>↓<span class="w">        </span>↓<span class="w">        </span>↓
<span class="w">  </span>ls<span class="w">       </span>-l<span class="w">    </span>/etc<span class="w"> </span>/bin
</pre></div>
</div>
<p>其中command是命令的名称，-options是对命令行为的一个或多个调整，参数（arguments）是命令操作的一个或多个对象。</p>
<p>在<code class="docutils literal notranslate"><span class="pre">ls</span></code>的情况下，我们看到<code class="docutils literal notranslate"><span class="pre">ls</span></code>是命令的名称，它可以有一个或多个选项，如<code class="docutils literal notranslate"><span class="pre">-a</span></code>和<code class="docutils literal notranslate"><span class="pre">-l</span></code>，并且它可以对一个或多个文件或目录进行操作。</p>
</section>
<section id="long-format">
<h3>关于长格式（Long Format）<a class="headerlink" href="#long-format" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>-rw-------   1 me       me            576 Apr 17  2019 weather.txt
drwxr-xr-x   6 me       me           1024 Oct  9  2019 web_page
-rw-rw-r--   1 me       me         276480 Feb 11 20:41 web_site.tar
-rw-------   1 me       me           5743 Dec 16  2018 xmas_file.txt

----------  -------  -------     -------- ------------ -------------
    |          |        |            |         |             |
    |          |        |            |         |           文件名
    |          |        |            |         |
    |          |        |            |         +---       修改时间
    |          |        |            |
    |          |        |            +-------------   大小（以字节为单位）
    |          |        |   
    |          |        +--------------------------          组
    |          |
    |          +-----------------------------------        所有者
    |
    +----------------------------------------------       文件权限
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">文件名（File</span> <span class="pre">Name）</span></code>文件或目录的名称。</p>
<p><code class="docutils literal notranslate"><span class="pre">修改时间（Modification</span> <span class="pre">Time）</span></code>上次修改文件的时间。如果上次修改发生在过去六个月以上，则会显示日期和年份；否则会显示一天中的时间。</p>
<p><code class="docutils literal notranslate"><span class="pre">大小（Size）</span></code>文件的大小（以字节为单位）</p>
<p><code class="docutils literal notranslate"><span class="pre">组（Group）</span></code>除文件所有者外，还具有文件权限的组的名称。</p>
<p><code class="docutils literal notranslate"><span class="pre">所有者（Owner）</span></code>拥有该文件的用户的名称。</p>
<p><code class="docutils literal notranslate"><span class="pre">文件权限（File</span> <span class="pre">Permissions）</span></code>文件访问权限的表示。
第一个字符是文件的类型。<code class="docutils literal notranslate"><span class="pre">-</span></code>表示常规（普通）文件。<code class="docutils literal notranslate"><span class="pre">D</span></code>表示一个目录。</p>
<p>第二组三个字符代表文件所有者的读取、写入和执行（<code class="docutils literal notranslate"><span class="pre">r</span></code>、<code class="docutils literal notranslate"><span class="pre">w</span></code>、<code class="docutils literal notranslate"><span class="pre">x</span></code>）权限。</p>
<p>接下来的三个代表文件组的权利，最后三个代表授予其他人的权利。</p>
</section>
<section id="less">
<h3><code class="docutils literal notranslate"><span class="pre">less</span></code><a class="headerlink" href="#less" title="Link to this heading"></a></h3>
<p>Less是一个让我们查看文本文件的程序。这非常方便，因为许多用于控制和配置Linux的文件都是人类可读的，只需键入<code class="docutils literal notranslate"><span class="pre">less</span> <span class="pre">file_name</span></code>即可调用。</p>
<p>启动<code class="docutils literal notranslate"><span class="pre">less</span></code>后，<code class="docutils literal notranslate"><span class="pre">less</span></code>将一次显示一页的文本文件。我们可以使用<code class="docutils literal notranslate"><span class="pre">Page</span> <span class="pre">Up</span></code>和<code class="docutils literal notranslate"><span class="pre">Page</span> <span class="pre">Down</span></code>键来浏览文本文件。为了使<code class="docutils literal notranslate"><span class="pre">less</span></code>退出，我们键入“q”。以下是一些<code class="docutils literal notranslate"><span class="pre">less</span></code>接受的命令：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Command</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page Up 或 b</td>
<td>向后滚动一页</td>
</tr>
<tr>
<td>Page Down 或 space</td>
<td>向前滚动一页</td>
</tr>
<tr>
<td>G</td>
<td>转到文本文件的末尾</td>
</tr>
<tr>
<td>1G</td>
<td>转到文本文件的开头</td>
</tr>
<tr>
<td>/characters</td>
<td>在文本文件中向前搜索第一个指定字符的出现的位置</td>
</tr>
<tr>
<td>n</td>
<td>重复之前的搜索</td>
</tr>
<tr>
<td>h</td>
<td>显示一个完整的列表——less的命令和选项</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
</tbody>
</table></section>
<section id="file">
<h3><code class="docutils literal notranslate"><span class="pre">file</span></code><a class="headerlink" href="#file" title="Link to this heading"></a></h3>
<p>当我们在Linux系统中闲逛时，在我们尝试查看文件之前，确定文件包含哪种数据是有帮助的。这就是<code class="docutils literal notranslate"><span class="pre">file</span></code>命令进入的地方。<code class="docutils literal notranslate"><span class="pre">file</span></code>将检查一个文件，并告诉我们它是哪种文件。</p>
<p>要使用<code class="docutils literal notranslate"><span class="pre">file</span></code>程序，我们只需键入：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>file<span class="w"> </span>name_of_file
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">file</span></code>程序可以识别大多数类型的文件，例如：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
<th>是否可以作为文本查看</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII text</td>
<td>文本</td>
<td>是</td>
</tr>
<tr>
<td>Bourne-Again shell script text</td>
<td>bash脚本</td>
<td>是</td>
</tr>
<tr>
<td>ELF 64-bit LSB executable</td>
<td>可执行的二进制程序</td>
<td>否</td>
</tr>
<tr>
<td>ELF 64-bit LSB shared object</td>
<td>共享图书馆</td>
<td>否</td>
</tr>
<tr>
<td>GNU tar archive</td>
<td>磁带存档文件。存储文件组的常见方式</td>
<td>否，使用<code>tar</code>的<code>tvf</code>命令查看</td>
</tr>
<tr>
<td>gzip compressed data</td>
<td>用gzip压缩的存档</td>
<td>否</td>
</tr>
<tr>
<td>HTML document text</td>
<td>一个网页</td>
<td>是</td>
</tr>
<tr>
<td>JPEG image data</td>
<td>压缩的JPEG图像</td>
<td>否</td>
</tr>
<tr>
<td>PostScript document text</td>
<td>PostScript文件</td>
<td>是</td>
</tr>
<tr>
<td>Zip archive data</td>
<td>用zip压缩的内容</td>
<td>否</td>
</tr>
</tbody>
</table><p>虽然看起来大多数文件不能作为文本查看，但我们将看到操作系统的许多功能都由文本配置文件（text configuration files）和shell脚本（shell scripts）控制。</p>
</section>
</section>
<section id="linux-a-guided-tour">
<h2>四、一次Linux旅行（A Guided Tour）<a class="headerlink" href="#linux-a-guided-tour" title="Link to this heading"></a></h2>
<p>对于下面列出的每个目录，请执行以下操作：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cd</span></code>进入每个目录。</p></li>
<li><p>使用<code class="docutils literal notranslate"><span class="pre">ls</span></code>列出目录的内容。</p></li>
<li><p>如果有有趣的文件，请使用<code class="docutils literal notranslate"><span class="pre">file</span></code>命令来确定其内容。</p></li>
<li><p>对于文本文件，请使用<code class="docutils literal notranslate"><span class="pre">less</span></code>来查看它们。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>文件系统开始的根目录（root directory）。根目录可能只包含子目录（subdirectories）。</td>
</tr>
<tr>
<td>/boot</td>
<td>这是保存Linux内核（kernel）和引导加载程序文件（boot loader files）的地方。内核是一个名为<strong>vmlinuz</strong>的文件。</td>
</tr>
<tr>
<td>/etc</td>
<td><code>/etc</code>目录包含系统的配置文件(configuration files)。 <code>/etc</code>中的所有文件都应该是文本文件(text files)。</td>
</tr>
<tr>
<td>/bin, /usr/bin</td>
<td>这两个目录包含系统的大部分程序。<code>/Bin</code>目录具有系统操作所需的基本程序(essential programs)，而<code>/usr/bin</code>包含系统用户的应用程序。</td>
</tr>
<tr>
<td>/sbin, /usr/sbin</td>
<td><code>sbin</code>目录包含用于系统管理(system administration)的程序，主要用于超级用户(superuser)。</td>
</tr>
<tr>
<td>/usr</td>
<td><code>/Usr</code>目录包含各种支持用户应用程序的内容。</td>
</tr>
<tr>
<td>/usr/local</td>
<td><code>/Usr/local</code>及其子目录用于安装用于本地机器上的软件和其他文件。这意味着不属于官方发行版（通常在<code>/usr/bin</code>）的软件在这里。当您在系统上找到要安装的有趣程序时，它们应该安装在<code>/usr/local</code>目录之中。大多数情况下，选择的目录是<code>/usr/local/bin</code>。</td>
</tr>
<tr>
<td>/var</td>
<td><code>/Var</code>目录包含随着系统运行而更改的文件</td>
</tr>
<tr>
<td>/lib</td>
<td>共享库(shared libraries)（类似于其他操作系统中的<strong>动态链接库,DLL</strong>）保存在这里。</td>
</tr>
<tr>
<td>/home</td>
<td><code>/Home</code>是用户保留个人工作的地方。一般来说，这是用户唯一允许写入文件的地方。</td>
</tr>
<tr>
<td>/root</td>
<td>这是超级用户的主目录。</td>
</tr>
<tr>
<td>/tmp</td>
<td><code>/Tmp</code>是一个程序可以在其中写入临时文件的目录。</td>
</tr>
<tr>
<td>/dev</td>
<td><code>/dev</code>目录是一个特殊的目录，因为它并不真正包含通常意义上的文件。相反，它包含系统可用的设备。在Linux（如Unix）中，设备被视为文件。您可以像读取文件一样读取和写入设备。例如，<code>/dev/fd0</code>是第一个软盘驱动器，<code>/dev/sda</code>是第一个硬盘驱动器。内核理解的所有设备都在这里表示。</td>
</tr>
<tr>
<td>/proc</td>
<td><code>/proc</code>目录也很特别,此目录不包含文件。事实上，这个目录实际上根本不存在。它是完全虚拟的。<code>/proc</code>目录包含内核本身的小窥视孔（little peep holes into the kernel itself）。此目录中有一组编号条目（numbered entries），对应于系统上运行的所有进程。此外，还有一些命名条目（named entries）允许访问系统的当前配置。其中许多条目都可以查看。尝试查看/<code>proc/cpuinfo</code>，此条目将告诉您内核对系统CPU的看法。</td>
</tr>
<tr>
<td>/media</td>
<td>一个以特殊方式使用的普通目录。<code>/Media</code>目录用于挂载点（mount points）。不同的物理存储设备（如硬盘驱动器）在不同的地方连接到文件系统树（ file system tree）。这种将设备连接到树的过程称为安装（mounting）。要让设备可用，必须首先安装它。</td>
</tr>
</tbody>
</table><p>关于以上目录更多信息请访问：<a class="reference external" href="http://linuxcommand.org/lc3_lts0040.php">Second Lesson: A Guided Tour</a></p>
<section id="id4">
<h3>我的Linux旅行<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>先访问一下<code class="docutils literal notranslate"><span class="pre">/boot</span></code>，列出其中的文件：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/boot
shimofang@shimofang-virtual-machine:/boot$<span class="w"> </span>ls
config-6.2.0-26-generic<span class="w">      </span>memtest86+.elf
config-6.2.0-33-generic<span class="w">      </span>memtest86+_multiboot.bin
efi<span class="w">                          </span>System.map-6.2.0-26-generic
grub<span class="w">                         </span>System.map-6.2.0-33-generic
initrd.img<span class="w">                   </span>vmlinuz
initrd.img-6.2.0-26-generic<span class="w">  </span>vmlinuz-6.2.0-26-generic
initrd.img-6.2.0-33-generic<span class="w">  </span>vmlinuz-6.2.0-33-generic
initrd.img.old<span class="w">               </span>vmlinuz.old
memtest86+.bin
</pre></div>
</div>
<p>我想看看Linux内核是个什么东西：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:/boot$<span class="w"> </span>file<span class="w"> </span>vmlinuz
vmlinuz:<span class="w"> </span>symbolic<span class="w"> </span>link<span class="w"> </span>to<span class="w"> </span>vmlinuz-6.2.0-33-generic
shimofang@shimofang-virtual-machine:/boot$<span class="w"> </span>file<span class="w"> </span>vmlinuz-6.2.0-33-generic
vmlinuz-6.2.0-33-generic:<span class="w"> </span>regular<span class="w"> </span>file,<span class="w"> </span>no<span class="w"> </span><span class="nb">read</span><span class="w"> </span>permission
</pre></div>
</div>
<p>Shell告诉我<code class="docutils literal notranslate"><span class="pre">vmlinuz</span></code>是一个符号链接（symbolic links），指向<code class="docutils literal notranslate"><span class="pre">vmlinuz-6.2.0-33-generic</span></code>。于是尝试访问这个对象，结果被无情拒绝（因为是$不是#）。。。好吧，换个目录试试：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:/boot$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>..
shimofang@shimofang-virtual-machine:/$<span class="w">  </span><span class="nb">cd</span><span class="w"> </span>/etc
shimofang@shimofang-virtual-machine:/etc$<span class="w"> </span>ls
acpi<span class="w">                           </span>hostid<span class="w">               </span>polkit-1
adduser.conf<span class="w">                   </span>hostname<span class="w">             </span>ppp
alsa<span class="w">                           </span>hosts<span class="w">                </span>printcap
alternatives<span class="w">                   </span>hosts.allow<span class="w">          </span>profile


and<span class="w"> </span>many<span class="w"> </span>more...


fwupd<span class="w">                          </span>NetworkManager<span class="w">       </span>udisks2
gai.conf<span class="w">                       </span>networks<span class="w">             </span>ufw
gdb<span class="w">                            </span>newt<span class="w">                 </span>update-manager
gdm3<span class="w">                           </span>nftables.conf<span class="w">        </span>update-motd.d
geoclue<span class="w">                        </span>nsswitch.conf<span class="w">        </span>update-notifier
ghostscript<span class="w">                    </span>openvpn<span class="w">              </span>UPower


shimofang@shimofang-virtual-machine:/etc$<span class="w"> </span>file<span class="w"> </span>hostid
hostid:<span class="w"> </span>data
shimofang@shimofang-virtual-machine:/etc$<span class="w"> </span>file<span class="w"> </span>networks
networks:<span class="w"> </span>ASCII<span class="w"> </span>text
shimofang@shimofang-virtual-machine:/etc$<span class="w"> </span>less<span class="w"> </span>networks
</pre></div>
</div>
<p>访问<code class="docutils literal notranslate"><span class="pre">hostid</span></code>，结果为<code class="docutils literal notranslate"><span class="pre">data</span></code>型。换一个<code class="docutils literal notranslate"><span class="pre">networks</span></code>，终于找到了<code class="docutils literal notranslate"><span class="pre">ASCII</span> <span class="pre">text</span></code>型！！！最后用用<code class="docutils literal notranslate"><span class="pre">less</span></code>命令查看。</p>
</section>
</section>
<section id="manipulating-files">
<h2>五、操作文件（Manipulating Files）<a class="headerlink" href="#manipulating-files" title="Link to this heading"></a></h2>
<p>这个部分将会使用到四个命令：</p>
<p><code class="docutils literal notranslate"><span class="pre">cp</span></code> - 复制文件和目录</p>
<p><code class="docutils literal notranslate"><span class="pre">mv</span></code> - 移动或重命名文件和目录</p>
<p><code class="docutils literal notranslate"><span class="pre">rm</span></code> - 删除文件和目录</p>
<p><code class="docutils literal notranslate"><span class="pre">mkdir</span></code> - 创建目录</p>
<p>这四个命令是最常用的Linux命令之一。它们是操作文件和目录的基本命令。</p>
<p>不过这些命令执行的一些任务如果使用图形文件管理器（graphical file manager）更容易完成。使用文件管理器，您可以将文件从一个目录拖放到另一个目录，剪切和粘贴文件，删除文件等。那么，为什么要使用这些旧的命令行程序呢？</p>
<p>答案是权力和灵活性。虽然使用图形文件管理器执行简单的文件操作很容易，但使用命令行程序可以更容易地执行复杂的任务。例如，您如何将所有HTML文件从一个目录复制到另一个目录，且只复制目标目录中不存在或比目标目录中版本更新的文件？使用文件管理器相当困难，但使用命令行非常简单：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:/$<span class="w"> </span>cp<span class="w"> </span>-u<span class="w"> </span>*.html<span class="w"> </span>destination
</pre></div>
</div>
<section id="wildcards">
<h3>通配符（Wildcards）<a class="headerlink" href="#wildcards" title="Link to this heading"></a></h3>
<p>由于shell经常使用文件名，它提供了特殊字符来帮助您快速指定文件名组。这些特殊字符被称为通配符。通配符允许您根据字符模式选择文件名。下表列出了通配符及其选择的内容：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任何字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任何单个字符</td>
</tr>
<tr>
<td>[characters]</td>
<td>匹配作为集合字符成员中的任何字符。字符集也可以表示为 POSIX字符类，例如： <code>[:alnum:]</code>   字母数字字符； <code>[:alpha:]</code>   字母字符； <code>[:digit:]</code>   数字 <code>[:upper:]</code>；  大写字母字符 <code>[:lower:]</code>；  小写字母字符</td>
</tr>
<tr>
<td>[!characters]</td>
<td>匹配任何不是字符集里的字符</td>
</tr>
</tbody>
</table><p>使用通配符，可以为文件名构建非常复杂的选择标准。以下是一些模式示例以及它们匹配的内容：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>格式</th>
<th>匹配内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>所有文件名</td>
</tr>
<tr>
<td><code>g*</code></td>
<td>以字符“g”开头的所有文件名</td>
</tr>
<tr>
<td><code>b*.txt</code></td>
<td>以字符“b”开头，以字符“.txt”结尾的所有文件名</td>
</tr>
<tr>
<td><code>Data???</code></td>
<td>任何以字符“Data”开头的文件名，后跟3个字符</td>
</tr>
<tr>
<td><code>[abc]*</code></td>
<td>任何以“a”或“b”或“c”开头的文件名，后跟任何其他字符</td>
</tr>
<tr>
<td><code>[[:upper:]]*</code></td>
<td>任何以一个大写字母开头的文件名</td>
</tr>
<tr>
<td><code>BACKUP.[[:digit:]][[:digit:]]</code></td>
<td>以字符“BACKUP”开头的任何文件名，后跟正好两个数字</td>
</tr>
<tr>
<td><code>*[![:lower:]]</code></td>
<td>任何不以小写字母结尾的文件名</td>
</tr>
</tbody>
</table></section>
<section id="cp">
<h3><code class="docutils literal notranslate"><span class="pre">cp</span></code><a class="headerlink" href="#cp" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">cp</span></code>程序复制文件和目录，它还可用于将多个文件（和/或目录）复制到不同的目录。</p>
<p>一些有用的<code class="docutils literal notranslate"><span class="pre">cp</span></code>用例及其可选项（-options）：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>命令</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cp file1 file2</code></td>
<td>将<code>file1</code>的内容复制到<code>file2</code>中。如果<code>file2</code>不存在，则创建它；否则，<code>file2</code>将用<code>file1</code>的内容静默覆盖。</td>
</tr>
<tr>
<td><code>cp -i file1 file2</code></td>
<td>如上所述。但由于指定了“<code>-i</code>”（交互式，interactive）选项，如果<code>file2</code>存在，则在用<code>file1</code>的内容覆盖之前会提示用户。</td>
</tr>
<tr>
<td><code>cp file1 dir1</code></td>
<td>在目录<code>dir1</code>内将<code>file1</code>的内容复制到<code>dir1</code>的名为<code>file1</code>的文件中。</td>
</tr>
<tr>
<td><code>cp -R dir1 dir2</code></td>
<td>复制目录<code>dir1</code>的内容。如果目录<code>dir2</code>不存在，则创建它。否则，它会在目录<code>dir2</code>中创建一个名为<code>dir1</code>的目录。</td>
</tr>
</tbody>
</table></section>
<section id="mv">
<h3><code class="docutils literal notranslate"><span class="pre">mv</span></code><a class="headerlink" href="#mv" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">mv</span></code>命令根据其使用方式<strong>移动</strong>或<strong>重命名</strong>文件和目录。它要么将一个或多个文件移动到不同的目录，要么将重命名一个文件或目录。</p>
<p>一些有用的<code class="docutils literal notranslate"><span class="pre">mv</span></code>用例及其可选项（-options）：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>命令</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mv file1 file2</code></td>
<td>如果<code>file2</code>不存在，则<code>file1</code>将重命名为<code>file2</code>。如果<code>file2</code>存在，其内容将静默替换为<code>file1</code>的内容。</td>
</tr>
<tr>
<td><code>mv -i file1 file2</code></td>
<td>如上所述，由于指定了“-i”（交互式）选项，如果<code>file2</code>存在，则在用<code>file1</code>的内容覆盖之前会提示用户。</td>
</tr>
<tr>
<td><code>mv file1 file2 dir1</code></td>
<td>文件<code>file1</code>和<code>file2</code>被移动到目录<code>dir1</code>。如果<code>dir1</code>不存在，<code>mv</code>将以错误退出。</td>
</tr>
<tr>
<td><code>mv dir1 dir2</code></td>
<td>如果<code>dir2</code>不存在，则<code>dir1</code>将重命名为<code>dir2</code>。如果<code>dir2</code>存在，则目录<code>dir1</code>将在目录<code>dir2</code>内移动。</td>
</tr>
</tbody>
</table></section>
<section id="rm">
<h3><code class="docutils literal notranslate"><span class="pre">rm</span></code><a class="headerlink" href="#rm" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">rm</span></code>命令移除（删除）文件和目录。使用递归选项<code class="docutils literal notranslate"><span class="pre">-r</span></code>，<code class="docutils literal notranslate"><span class="pre">rm</span></code>也可用于删除目录。</p>
<p>一些有用的<code class="docutils literal notranslate"><span class="pre">rm</span></code>用例及其可选项（-options）：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>命令</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rm file1 file2</code></td>
<td>删除<code>file1</code>和<code>file2</code>。</td>
</tr>
<tr>
<td><code>rm -i file1 file2</code></td>
<td>如上所述，由于指定了“<code>-i</code>”（交互式）选项，因此在删除每个文件之前会提示用户。</td>
</tr>
<tr>
<td><code>rm -r dir1 dir2</code></td>
<td>目录<code>dir1</code>和<code>dir2</code>及其所有内容将被删除。</td>
</tr>
</tbody>
</table></section>
<section id="id5">
<h3>谨慎使用<code class="docutils literal notranslate"><span class="pre">rm</span></code><a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>Linux没有undelete命令。一旦你用<code class="docutils literal notranslate"><span class="pre">rm</span></code>删除了一些东西，它就消失了。如果您不小心，特别是通配符，可以使用<code class="docutils literal notranslate"><span class="pre">rm</span></code>对系统造成巨大损害。</p>
<p>在将<code class="docutils literal notranslate"><span class="pre">rm</span></code>与通配符一起使用之前，请尝试这个有用的技巧：</p>
<p><strong>使用ls构建命令。通过这样做，您可以在删除文件之前看到通配符的效果。使用ls测试命令后，用向上箭头键调用命令，然后在命令中用rm代替ls。</strong></p>
</section>
<section id="mkdir">
<h3><code class="docutils literal notranslate"><span class="pre">mkdir</span></code><a class="headerlink" href="#mkdir" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">mkdir</span></code>命令用于创建目录。</p>
</section>
<section id="id6">
<h3>使用带有通配符的命令<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>命令</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cp *.txt text_files</code></td>
<td>将当前工作目录中以字符“<code>.txt</code>”结尾的所有文件复制到名为<code>text_files</code>的现有目录中。</td>
</tr>
<tr>
<td><code>mv dir1 ../*.bak dir2</code></td>
<td>将当前工作目录的父目录中的子目录<code>dir1</code>和以“<code>.bak</code>”结尾的所有文件移动到名为<code>dir2</code>的现有目录。</td>
</tr>
<tr>
<td><code>rm *~</code></td>
<td>删除当前工作目录中以字符“<code>~</code>”结尾的所有文件。一些应用程序使用此命名方案创建备份文件。使用此命令会将它们从目录中清除出来。</td>
</tr>
</tbody>
</table></section>
</section>
<section id="working-with-commands">
<h2>六、使用命令工作（Working with Commands）<a class="headerlink" href="#working-with-commands" title="Link to this heading"></a></h2>
<p>这个部分将会使用到四个命令：</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> - 显示有关命令类型的信息</p>
<p><code class="docutils literal notranslate"><span class="pre">which</span></code> -找到一个命令</p>
<p><code class="docutils literal notranslate"><span class="pre">help</span></code>  -显示shell内置的参考页面</p>
<p><code class="docutils literal notranslate"><span class="pre">man</span></code>   - 显示在线命令参考</p>
<section id="id7">
<h3>什么是“命令”？<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>命令可以是4种不同类型之一：</p>
<ul class="simple">
<li><p><strong>一个可执行程序（An executable program）</strong>。就像我们在<code class="docutils literal notranslate"><span class="pre">/usr/bin</span></code>中看到的所有文件一样。在这个类别中，程序可以编译二进制文件，如用<code class="docutils literal notranslate"><span class="pre">C</span></code>和<code class="docutils literal notranslate"><span class="pre">C++</span></code>编写的程序，或用<code class="docutils literal notranslate"><span class="pre">shell</span></code>、<code class="docutils literal notranslate"><span class="pre">Perl</span></code>、<code class="docutils literal notranslate"><span class="pre">Python</span></code>、<code class="docutils literal notranslate"><span class="pre">Ruby</span></code>等脚本语言编写的程序。</p></li>
<li><p><strong>内置在shell本身的命令（A command built into the shell itself）</strong>。bash提供了许多内部称为shell内置的命令。例如，<code class="docutils literal notranslate"><span class="pre">cd</span></code>命令是一个内置的shell。</p></li>
<li><p><strong>外壳功能（A shell function）</strong>。这些是集成到环境（environment）中的微型外壳脚本。我们将在后面的课程中介绍配置环境和编写shell函数，但现在请注意它们的存在。</p></li>
<li><p><strong>一个别名（An alias）</strong>。我们可以定义自己的命令，由其他命令构建。这将在后面的课程中讨论。</p></li>
</ul>
</section>
<section id="type">
<h3>识别命令——<code class="docutils literal notranslate"><span class="pre">type</span></code><a class="headerlink" href="#type" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code>命令是一个内置的shell，在给定特定命令名称的情况下，显示shell将执行的命令的类型（displays the kind of command the shell will execute）。</p>
<p>它的工作原理是这样的：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="w"> </span><span class="nb">command</span>
</pre></div>
</div>
<p>其中“<code class="docutils literal notranslate"><span class="pre">command</span></code>”是我们要检查的命令的名称。</p>
<p>以下是一些例子：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="nb">type</span>
<span class="nb">type</span><span class="w"> </span>is<span class="w"> </span>a<span class="w"> </span>shell<span class="w"> </span><span class="nb">builtin</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">type</span><span class="w"> </span>ls
ls<span class="w"> </span>is<span class="w"> </span>aliased<span class="w"> </span>to<span class="w"> </span><span class="sb">`</span>ls<span class="w"> </span>--color<span class="o">=</span>auto<span class="err">&#39;</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">type</span><span class="w"> </span>clear
clear<span class="w"> </span>is<span class="w"> </span>hashed<span class="w"> </span><span class="o">(</span>/usr/bin/clear<span class="o">)</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">type</span><span class="w"> </span>cp
cp<span class="w"> </span>is<span class="w"> </span>/usr/bin/cp
</pre></div>
</div>
<p>我们看到了不同命令的结果。请注意，<code class="docutils literal notranslate"><span class="pre">ls</span></code>命令实际上是<code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">--color=auto</span></code>命令的别名，现在我们知道为什么ls的输出以彩色显示了。</p>
</section>
<section id="which">
<h3>识别命令——<code class="docutils literal notranslate"><span class="pre">which</span></code><a class="headerlink" href="#which" title="Link to this heading"></a></h3>
<p>有时一个系统上安装了多个版本的可执行程序。虽然这在桌面系统上并不常见，但在大型服务器上并不罕见。要确定给定可执行文件的确切位置，使用<code class="docutils literal notranslate"><span class="pre">which</span></code>命令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>which<span class="w"> </span>ls
/usr/bin/ls
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">which</span></code>仅适用于可执行程序（executable programs），不适用于替代实际可执行程序的内置（builtins）或别名（aliases）。</p>
</section>
<section id="help">
<h3>命令文档——<code class="docutils literal notranslate"><span class="pre">help</span></code><a class="headerlink" href="#help" title="Link to this heading"></a></h3>
<p>Bash为每个内置的shell都有一个帮助文档。要使用它，请键入“<code class="docutils literal notranslate"><span class="pre">help</span></code>”，后跟内置shell的名称。或者，我们可以添加<code class="docutils literal notranslate"><span class="pre">-m</span></code>选项来更改输出的格式。例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">type</span><span class="w"> </span>rm
rm<span class="w"> </span>is<span class="w"> </span>/usr/bin/rm
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">help</span><span class="w"> </span>-m<span class="w"> </span>rm
bash:<span class="w"> </span>help:<span class="w"> </span>no<span class="w"> </span><span class="nb">help</span><span class="w"> </span>topics<span class="w"> </span>match<span class="w"> </span><span class="sb">`</span>rm<span class="s1">&#39;.  Try `help help&#39;</span><span class="w"> </span>or<span class="w"> </span><span class="sb">`</span>man<span class="w"> </span>-k<span class="w"> </span>rm<span class="s1">&#39; or `info rm&#39;</span>.
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="nb">cd</span>
<span class="nb">cd</span><span class="w"> </span>is<span class="w"> </span>a<span class="w"> </span>shell<span class="w"> </span><span class="nb">builtin</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">help</span><span class="w"> </span>-m<span class="w"> </span><span class="nb">cd</span>
NAME
<span class="w">    </span><span class="nb">cd</span><span class="w"> </span>-<span class="w"> </span>Change<span class="w"> </span>the<span class="w"> </span>shell<span class="w"> </span>working<span class="w"> </span>directory.

SYNOPSIS
<span class="w">    </span><span class="nb">cd</span><span class="w"> </span><span class="o">[</span>-L<span class="p">|</span><span class="o">[</span>-P<span class="w"> </span><span class="o">[</span>-e<span class="o">]]</span><span class="w"> </span><span class="o">[</span>-@<span class="o">]]</span><span class="w"> </span><span class="o">[</span>dir<span class="o">]</span>

DESCRIPTION
<span class="w">    </span>Change<span class="w"> </span>the<span class="w"> </span>shell<span class="w"> </span>working<span class="w"> </span>directory.
<span class="w">    </span>
<span class="w">    </span>Change<span class="w"> </span>the<span class="w"> </span>current<span class="w"> </span>directory<span class="w"> </span>to<span class="w"> </span>DIR.<span class="w">  </span>The<span class="w"> </span>default<span class="w"> </span>DIR<span class="w"> </span>is<span class="w"> </span>the<span class="w"> </span>value<span class="w"> </span>of<span class="w"> </span>the
<span class="w">    </span>HOME<span class="w"> </span>shell<span class="w"> </span>variable.
<span class="w">    </span>
<span class="w">    </span>The<span class="w"> </span>variable<span class="w"> </span>CDPATH<span class="w"> </span>defines<span class="w"> </span>the<span class="w"> </span>search<span class="w"> </span>path<span class="w"> </span><span class="k">for</span><span class="w"> </span>the<span class="w"> </span>directory<span class="w"> </span>containing
<span class="w">    </span>DIR.<span class="w">  </span>Alternative<span class="w"> </span>directory<span class="w"> </span>names<span class="w"> </span><span class="k">in</span><span class="w"> </span>CDPATH<span class="w"> </span>are<span class="w"> </span>separated<span class="w"> </span>by<span class="w"> </span>a<span class="w"> </span>colon<span class="w"> </span><span class="o">(</span>:<span class="o">)</span>.
<span class="w">    </span>A<span class="w"> </span>null<span class="w"> </span>directory<span class="w"> </span>name<span class="w"> </span>is<span class="w"> </span>the<span class="w"> </span>same<span class="w"> </span>as<span class="w"> </span>the<span class="w"> </span>current<span class="w"> </span>directory.<span class="w">  </span>If<span class="w"> </span>DIR<span class="w"> </span>begins
<span class="w">    </span>with<span class="w"> </span>a<span class="w"> </span>slash<span class="w"> </span><span class="o">(</span>/<span class="o">)</span>,<span class="w"> </span><span class="k">then</span><span class="w"> </span>CDPATH<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>used.
<span class="w">    </span>
<span class="w">    </span>If<span class="w"> </span>the<span class="w"> </span>directory<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>found,<span class="w"> </span>and<span class="w"> </span>the<span class="w"> </span>shell<span class="w"> </span>option<span class="w"> </span><span class="sb">`</span>cdable_vars<span class="s1">&#39; is set,</span>
<span class="s1">    the word is assumed to be  a variable name.  If that variable has a value,</span>
<span class="s1">    its value is used for DIR.</span>
<span class="s1">    </span>
<span class="s1">    Options:</span>
<span class="s1">      -L	force symbolic links to be followed: resolve symbolic</span>
<span class="s1">    		links in DIR after processing instances of `..&#39;</span>
<span class="w">      </span>-P<span class="w">	</span>use<span class="w"> </span>the<span class="w"> </span>physical<span class="w"> </span>directory<span class="w"> </span>structure<span class="w"> </span>without<span class="w"> </span>following
<span class="w">    		</span>symbolic<span class="w"> </span>links:<span class="w"> </span>resolve<span class="w"> </span>symbolic<span class="w"> </span>links<span class="w"> </span><span class="k">in</span><span class="w"> </span>DIR<span class="w"> </span>before
<span class="w">    		</span>processing<span class="w"> </span>instances<span class="w"> </span>of<span class="w"> </span><span class="sb">`</span>..<span class="s1">&#39;</span>
<span class="s1">      -e	if the -P option is supplied, and the current working</span>
<span class="s1">    		directory cannot be determined successfully, exit with</span>
<span class="s1">    		a non-zero status</span>
<span class="s1">      -@	on systems that support it, present a file with extended</span>
<span class="s1">    		attributes as a directory containing the file attributes</span>
<span class="s1">    </span>
<span class="s1">    The default is to follow symbolic links, as if `-L&#39;</span><span class="w"> </span>were<span class="w"> </span>specified.
<span class="w">    </span><span class="sb">`</span>..<span class="err">&#39;</span><span class="w"> </span>is<span class="w"> </span>processed<span class="w"> </span>by<span class="w"> </span>removing<span class="w"> </span>the<span class="w"> </span>immediately<span class="w"> </span>previous<span class="w"> </span>pathname<span class="w"> </span>component
<span class="w">    </span>back<span class="w"> </span>to<span class="w"> </span>a<span class="w"> </span>slash<span class="w"> </span>or<span class="w"> </span>the<span class="w"> </span>beginning<span class="w"> </span>of<span class="w"> </span>DIR.
<span class="w">    </span>
<span class="w">    </span>Exit<span class="w"> </span>Status:
<span class="w">    </span>Returns<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="k">if</span><span class="w"> </span>the<span class="w"> </span>directory<span class="w"> </span>is<span class="w"> </span>changed,<span class="w"> </span>and<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">$PWD</span><span class="w"> </span>is<span class="w"> </span><span class="nb">set</span><span class="w"> </span>successfully<span class="w"> </span>when
<span class="w">    </span>-P<span class="w"> </span>is<span class="w"> </span>used<span class="p">;</span><span class="w"> </span>non-zero<span class="w"> </span>otherwise.

SEE<span class="w"> </span>ALSO
<span class="w">    </span>bash<span class="o">(</span><span class="m">1</span><span class="o">)</span>

IMPLEMENTATION
<span class="w">    </span>GNU<span class="w"> </span>bash,<span class="w"> </span>version<span class="w"> </span><span class="m">5</span>.1.16<span class="o">(</span><span class="m">1</span><span class="o">)</span>-release<span class="w"> </span><span class="o">(</span>x86_64-pc-linux-gnu<span class="o">)</span>
<span class="w">    </span>Copyright<span class="w"> </span><span class="o">(</span>C<span class="o">)</span><span class="w"> </span><span class="m">2020</span><span class="w"> </span>Free<span class="w"> </span>Software<span class="w"> </span>Foundation,<span class="w"> </span>Inc.
<span class="w">    </span>License<span class="w"> </span>GPLv3+:<span class="w"> </span>GNU<span class="w"> </span>GPL<span class="w"> </span>version<span class="w"> </span><span class="m">3</span><span class="w"> </span>or<span class="w"> </span>later<span class="w"> </span>&lt;http://gnu.org/licenses/gpl.html&gt;
</pre></div>
</div>
<p>当方括号<code class="docutils literal notranslate"><span class="pre">[]</span></code>出现在命令语法的描述中时，它们表示可选项。</p>
<p>垂直条形字符<code class="docutils literal notranslate"><span class="pre">|</span></code>表示相互排斥的项目。</p>
<p>许多可执行程序支持“<code class="docutils literal notranslate"><span class="pre">--help</span></code>”选项，该选项显示命令支持的语法（syntax）选项的描述，一些程序不支持，但无论如何都要尝试一下。例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">type</span><span class="w"> </span>mkdir
mkdir<span class="w"> </span>is<span class="w"> </span>/usr/bin/mkdir
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>mkdir<span class="w"> </span>--help
Usage:<span class="w"> </span>mkdir<span class="w"> </span><span class="o">[</span>OPTION<span class="o">]</span>...<span class="w"> </span>DIRECTORY...
Create<span class="w"> </span>the<span class="w"> </span>DIRECTORY<span class="o">(</span>ies<span class="o">)</span>,<span class="w"> </span><span class="k">if</span><span class="w"> </span>they<span class="w"> </span><span class="k">do</span><span class="w"> </span>not<span class="w"> </span>already<span class="w"> </span>exist.

Mandatory<span class="w"> </span>arguments<span class="w"> </span>to<span class="w"> </span>long<span class="w"> </span>options<span class="w"> </span>are<span class="w"> </span>mandatory<span class="w"> </span><span class="k">for</span><span class="w"> </span>short<span class="w"> </span>options<span class="w"> </span>too.
<span class="w">  </span>-m,<span class="w"> </span>--mode<span class="o">=</span>MODE<span class="w">   </span><span class="nb">set</span><span class="w"> </span>file<span class="w"> </span>mode<span class="w"> </span><span class="o">(</span>as<span class="w"> </span><span class="k">in</span><span class="w"> </span>chmod<span class="o">)</span>,<span class="w"> </span>not<span class="w"> </span><span class="nv">a</span><span class="o">=</span>rwx<span class="w"> </span>-<span class="w"> </span><span class="nb">umask</span>
<span class="w">  </span>-p,<span class="w"> </span>--parents<span class="w">     </span>no<span class="w"> </span>error<span class="w"> </span><span class="k">if</span><span class="w"> </span>existing,<span class="w"> </span>make<span class="w"> </span>parent<span class="w"> </span>directories<span class="w"> </span>as<span class="w"> </span>needed
<span class="w">  </span>-v,<span class="w"> </span>--verbose<span class="w">     </span>print<span class="w"> </span>a<span class="w"> </span>message<span class="w"> </span><span class="k">for</span><span class="w"> </span>each<span class="w"> </span>created<span class="w"> </span>directory
<span class="w">  </span>-Z<span class="w">                   </span><span class="nb">set</span><span class="w"> </span>SELinux<span class="w"> </span>security<span class="w"> </span>context<span class="w"> </span>of<span class="w"> </span>each<span class="w"> </span>created<span class="w"> </span>directory
<span class="w">                         </span>to<span class="w"> </span>the<span class="w"> </span>default<span class="w"> </span><span class="nb">type</span>
<span class="w">      </span>--context<span class="o">[=</span>CTX<span class="o">]</span><span class="w">  </span>like<span class="w"> </span>-Z,<span class="w"> </span>or<span class="w"> </span><span class="k">if</span><span class="w"> </span>CTX<span class="w"> </span>is<span class="w"> </span>specified<span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>the<span class="w"> </span>SELinux
<span class="w">                         </span>or<span class="w"> </span>SMACK<span class="w"> </span>security<span class="w"> </span>context<span class="w"> </span>to<span class="w"> </span>CTX
<span class="w">      </span>--help<span class="w">     </span>display<span class="w"> </span>this<span class="w"> </span><span class="nb">help</span><span class="w"> </span>and<span class="w"> </span><span class="nb">exit</span>
<span class="w">      </span>--version<span class="w">  </span>output<span class="w"> </span>version<span class="w"> </span>information<span class="w"> </span>and<span class="w"> </span><span class="nb">exit</span>

GNU<span class="w"> </span>coreutils<span class="w"> </span>online<span class="w"> </span>help:<span class="w"> </span>&lt;https://www.gnu.org/software/coreutils/&gt;
Report<span class="w"> </span>any<span class="w"> </span>translation<span class="w"> </span>bugs<span class="w"> </span>to<span class="w"> </span>&lt;https://translationproject.org/team/&gt;
Full<span class="w"> </span>documentation<span class="w"> </span>&lt;https://www.gnu.org/software/coreutils/mkdir&gt;
or<span class="w"> </span>available<span class="w"> </span>locally<span class="w"> </span>via:<span class="w"> </span>info<span class="w"> </span><span class="s1">&#39;(coreutils) mkdir invocation&#39;</span>
</pre></div>
</div>
</section>
<section id="man">
<h3>正式文档——<code class="docutils literal notranslate"><span class="pre">man</span></code><a class="headerlink" href="#man" title="Link to this heading"></a></h3>
<p>大多数用于命令行的可执行程序都提供了称为手册或手册页（manual or man page）的正式文档。使用一个名为<code class="docutils literal notranslate"><span class="pre">man</span></code>的特殊寻呼程序来查看它们。它被这样使用：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>man<span class="w"> </span>program
</pre></div>
</div>
<p>其中“<code class="docutils literal notranslate"><span class="pre">program</span></code>”是查看命令的名称。手册页的格式略有不同，但通常包含标题、命令语法概要（synopsis of the command’s syntax）、命令目的的描述（a description of the command’s purpose）以及每个命令选项的列表和描述。手册页通常不包含示例，仅供参考，而不是教程。</p>
<p>在大多数Linux系统上，<code class="docutils literal notranslate"><span class="pre">man</span></code>使用<code class="docutils literal notranslate"><span class="pre">less</span></code>来显示手册页面，因此所有<code class="docutils literal notranslate"><span class="pre">less</span></code>的命令在显示页面时都可以使用。</p>
</section>
<section id="readme">
<h3>README和其他文档文件<a class="headerlink" href="#readme" title="Link to this heading"></a></h3>
<p>系统上安装的许多软件包都有位于<code class="docutils literal notranslate"><span class="pre">/usr/share/doc</span></code>目录中的文档文件。其中大部分以纯文本格式（plain text format）存储，并且可以用<code class="docutils literal notranslate"><span class="pre">less</span></code>查看。一些文件是HTML格式的，可以使用网络浏览器（web browser）查看。我们可能会遇到一些以“<code class="docutils literal notranslate"><span class="pre">.gz</span></code>”扩展名结尾的文件。这表明它们已被<code class="docutils literal notranslate"><span class="pre">gzip</span></code>压缩程序压缩。Gzip包包括一个称为<code class="docutils literal notranslate"><span class="pre">zless</span></code>的特殊<code class="docutils literal notranslate"><span class="pre">less</span></code>版本，该版本将显示gzip压缩文本文件的内容。</p>
</section>
</section>
<section id="i-o-i-o-redirection">
<h2>七、I/O重定向（I/O Redirection）<a class="headerlink" href="#i-o-i-o-redirection" title="Link to this heading"></a></h2>
<p>在本课中，我们将探索命令行程序（command line programs）使用的称为输入/输出重定向（I/O Redirection）的强大功能。正如我们所看到的，许多命令（如<code class="docutils literal notranslate"><span class="pre">ls</span></code>）在显示器上打印其输出。然而，情况不必如此。通过使用一些特殊符号，我们可以将许多命令的输出重定向（redirect）到文件、设备，甚至重定向到其他命令的输入。</p>
<section id="id8">
<h3>标准输出<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p>大多数显示结果的命令行程序通过将其结果发送到称为标准输出（standard output）的设施来执行此操作。默认情况下，标准输出将其内容定向到显示器。要将标准输出重定向到文件，使用“<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>”字符：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~/doc$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/home/shimofang/doc
shimofang@shimofang-virtual-machine:~/doc$<span class="w"> </span>mkdir<span class="w"> </span>Linux_Basics
shimofang@shimofang-virtual-machine:~/doc$<span class="w"> </span>ls
Linux_Basics
shimofang@shimofang-virtual-machine:~/doc$<span class="w"> </span><span class="nb">cd</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls
公共的<span class="w">  </span>模板<span class="w">  </span>视频<span class="w">  </span>图片<span class="w">  </span>下载<span class="w">  </span>音乐<span class="w">  </span>桌面<span class="w">  </span>doc<span class="w">  </span>snap
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls<span class="w"> </span>&gt;<span class="w"> </span>/home/shimofang/doc/Linux_Basics/file_list.txt
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/home/shimofang/doc/Linux_Basics
shimofang@shimofang-virtual-machine:~/doc/Linux_Basics$<span class="w"> </span>ls
file_list.txt
shimofang@shimofang-virtual-machine:~/doc/Linux_Basics$<span class="w"> </span>less<span class="w"> </span>file_list.txt
</pre></div>
</div>
<p>ls -l <code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">cp</span></code> &gt; “/home/shimofang/Doc/Linux_Basics/file with space.txt”
每次重复上述命令时，<code class="docutils literal notranslate"><span class="pre">file_list.txt</span></code>都会用命令<code class="docutils literal notranslate"><span class="pre">ls</span></code>的输出从头开始覆盖。为了将新结果附加到文件中，我们使用“<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>”。当附加结果时，新结果将添加到文件的末尾，从而使每次重复命令时文件更长。如果我们尝试附加重定向的输出时文件不存在，则将创建该文件。</p>
</section>
<section id="id9">
<h3>标准输入<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<p>许多命令可以接受来自称为标准输入（standard input）的设施的输入。默认情况下，标准输入从键盘获取其内容，但与标准输出一样，它可以被重定向。要从文件而不是键盘重定向标准输入，使用“<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>”字符：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~/doc/Linux_Basics$<span class="w"> </span>sort<span class="w"> </span>&lt;<span class="w"> </span>file_list.txt<span class="w"> </span>&gt;<span class="w"> </span>sorted_file_list.txt
shimofang@shimofang-virtual-machine:~/doc/Linux_Basics$<span class="w"> </span>ls
file_list.txt<span class="w">  </span>sorted_file_list.txt
</pre></div>
</div>
<p>正如我们所看到的，命令可以同时重定向其输入和输出。请注意，重定向的顺序并不重要。唯一的要求是重定向运算符（“<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>”和“<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>”）必须出现在命令中的其他选项（-options）和参数（arguments）之后。</p>
</section>
<section id="pipelines">
<h3>管道（Pipelines）<a class="headerlink" href="#pipelines" title="Link to this heading"></a></h3>
<p>我们可以用I/O重定向做的最有用和最强大的事情是将<strong>多个命令连接在一起，以形成所谓的管道（Pipelines）</strong>。对于管道，一个命令的标准输出被输入到另一个命令的标准输入中。这里有一个非常有用的例子：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span><span class="p">|</span><span class="w"> </span>less
</pre></div>
</div>
<p>在本例中，<code class="docutils literal notranslate"><span class="pre">ls</span></code>命令的输出被输入到<code class="docutils literal notranslate"><span class="pre">less</span></code>。通过使用这个“<code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">less</span></code>”技巧，我们可以使任何命令具有滚动的输出。</p>
<p>以下是一些可以尝试的例子：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ls -lt \| head</code></td>
<td>显示当前目录中的10个最新文件</td>
</tr>
<tr>
<td><code>du \| sort -nr</code></td>
<td>显示目录列表以及它们消耗的空间，从最大到最小排序</td>
</tr>
<tr>
<td><code>find . -type f -print \| wc -l</code></td>
<td>显示当前工作目录及其所有子目录中的文件总数。</td>
</tr>
</tbody>
</table></section>
<section id="filters">
<h3>过滤器（Filters）<a class="headerlink" href="#filters" title="Link to this heading"></a></h3>
<p>管道中经常使用的一种程序被称为过滤器（Filters）。过滤器接受标准输入（standard input）并对其进行操作，并将结果发送到标准输出。通过这种方式，它们可以组合起来，以强大的方式处理信息。以下是一些可以充当过滤器的常见程序：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>程序</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort</td>
<td>对标准输入进行排序，然后在标准输出上输出排序结果。</td>
</tr>
<tr>
<td>uniq</td>
<td>给定标准输入中排序的数据流，它会删除重复的数据行（即确保每行都是唯一的）。</td>
</tr>
<tr>
<td>grep</td>
<td>检查它从标准输入收到的每行数据，并输出包含指定字符模式（specified pattern of characters）的每行。</td>
</tr>
<tr>
<td>fmt</td>
<td>从标准输入中读取文本，然后在标准输出上输出格式化文本（formatted text）。</td>
</tr>
<tr>
<td>pr</td>
<td>从标准输入中获取文本输入，并将数据拆分为带有分页符、页眉和页脚的页面，以准备打印。</td>
</tr>
<tr>
<td>head</td>
<td>输出其输入的前几行。有助于获取文件的标头。</td>
</tr>
<tr>
<td>tail</td>
<td>输出其输入的最后几行。适用于从日志文件中获取最新条目等。</td>
</tr>
<tr>
<td>tr</td>
<td>翻译字符。可用于执行大写/小写转换或将行终止字符从一种类型更改为另一种类型（例如，将DOS文本文件转换为Unix风格的文本文件）等任务。</td>
</tr>
<tr>
<td>sed</td>
<td>流编辑器。可以进行比tr更复杂的文本翻译</td>
</tr>
<tr>
<td>awk</td>
<td>为构建过滤器而设计的整个编程语言。非常强大。</td>
</tr>
</tbody>
</table></section>
<section id="id10">
<h3>一些例子<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>1.<strong>从命令行打印。</strong> Linux提供了一个名为<code class="docutils literal notranslate"><span class="pre">lpr</span></code>的程序，该程序接受标准输入并将其发送到打印机。它经常与管道和过滤器（pipes and filters）一起使用。例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>cat<span class="w"> </span>poorly_formatted_report.txt<span class="w"> </span><span class="p">|</span><span class="w"> </span>fmt<span class="w"> </span><span class="p">|</span><span class="w"> </span>pr<span class="w"> </span><span class="p">|</span><span class="w"> </span>lpr
cat<span class="w"> </span>unsorted_list_with_dupes.txt<span class="w"> </span><span class="p">|</span><span class="w"> </span>sort<span class="w"> </span><span class="p">|</span><span class="w"> </span>uniq<span class="w"> </span><span class="p">|</span><span class="w"> </span>pr<span class="w"> </span><span class="p">|</span><span class="w"> </span>lpr
</pre></div>
</div>
<p>在第一个示例中，我们使用<code class="docutils literal notranslate"><span class="pre">cat</span></code>读取文件并将其输出到标准输出，该输出被输送到<code class="docutils literal notranslate"><span class="pre">fmt</span></code>的标准输入中。<code class="docutils literal notranslate"><span class="pre">fmt</span></code>将文本格式化为整洁的段落，并将其输出到标准输出中，该输出被输送到<code class="docutils literal notranslate"><span class="pre">pr</span></code>的标准输入中。<code class="docutils literal notranslate"><span class="pre">pr</span></code>将文本整齐地拆分为页面并输出到标准输出，该输出被输送到<code class="docutils literal notranslate"><span class="pre">lpr</span></code>的标准输入中。<code class="docutils literal notranslate"><span class="pre">lpr</span></code>将其标准输入并将其发送到打印机。</p>
<p>第二个示例从包含重复条目的未排序数据列表开始。首先，<code class="docutils literal notranslate"><span class="pre">cat</span></code>将列表发送到排序中，对其进行排序<code class="docutils literal notranslate"><span class="pre">sort</span></code>，并将其输入<code class="docutils literal notranslate"><span class="pre">uniq</span></code>，以删除任何重复项。下一个<code class="docutils literal notranslate"><span class="pre">pr</span></code>和<code class="docutils literal notranslate"><span class="pre">lpr</span></code>用于分页和打印列表。</p>
<p>2.<strong>查看<code class="docutils literal notranslate"><span class="pre">tar</span></code>文件的内容。</strong> 您通常会看到软件作为压缩的tar文件分发。这是一个传统的Unix风格的磁带存档文件（用tar创建），已用gzip压缩。您可以通过其传统文件扩展名“<code class="docutils literal notranslate"><span class="pre">.tar.gz</span></code>”或“<code class="docutils literal notranslate"><span class="pre">.tgz</span></code>”来识别这些文件。可以使用以下命令在Linux系统上查看此类文件的目录：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>tar<span class="w"> </span>tzvf<span class="w"> </span>name_of_file.tar.gz<span class="w"> </span><span class="p">|</span><span class="w"> </span>less
</pre></div>
</div>
</section>
</section>
<section id="expansion">
<h2>八、扩展（Expansion）<a class="headerlink" href="#expansion" title="Link to this heading"></a></h2>
<p>每次我们键入命令行并按回车键时，bash在执行命令之前都会对文本执行多个过程。我们已经看到了几个例子，一个简单的字符序列（例如“*”）对shell有很多意义。实现这一目标的过程被称为扩展（expansion）。通过扩展，我们键入一些东西，在shell作用于它之前，它被扩展为其他东西。为了演示我们的意思，让我们看看<code class="docutils literal notranslate"><span class="pre">echo</span></code>命令。<code class="docutils literal notranslate"><span class="pre">echo</span></code>是一个内置的shell，可以在标准输出上打印出其文本参数：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~/doc/Linux_Basics$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>I<span class="w"> </span>am<span class="w"> </span>mofang
I<span class="w"> </span>am<span class="w"> </span>mofang
</pre></div>
</div>
<p>传递给<code class="docutils literal notranslate"><span class="pre">echo</span></code>的任何参数都会显示。让我们试试另一个例子：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~/doc/Linux_Basics$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>*
file_list.txt<span class="w"> </span>sorted_file_list.txt
</pre></div>
</div>
<p>为什么<code class="docutils literal notranslate"><span class="pre">echo</span></code>没有打印“<code class="docutils literal notranslate"><span class="pre">*</span></code>”？</p>
<p>通配符<code class="docutils literal notranslate"><span class="pre">*</span></code>意味着匹配文件名中的任何字符，但我们在最初的讨论中没有看到的是shell是如何做到这一点的。简单的答案是，在执行<code class="docutils literal notranslate"><span class="pre">echo</span></code>命令之前，shell将<code class="docutils literal notranslate"><span class="pre">*</span></code>扩展为其他东西（在本例中，是当前工作目录中文件的名称）。当按下回车键时，shell会在执行命令之前自动展开命令行上的任何符合要求的字符，因此<code class="docutils literal notranslate"><span class="pre">echo</span></code>命令不会打印<code class="docutils literal notranslate"><span class="pre">*</span></code>，只有其扩展结果。知道这一点后，我们可以看到<code class="docutils literal notranslate"><span class="pre">echo</span></code>命令的行为是符合预期的。</p>
<section id="id11">
<h3>路径名扩展<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>通配符工作的机制称为路径名扩展（pathname expansion）。如果我们尝试我们在早期课程中使用的一些技术，我们将看到它们确实是扩展。给定一个看起来像这样的主目录：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls
模板<span class="w">  </span>桌面<span class="w">  </span>Doc<span class="w">  </span>Downloads<span class="w">  </span>Music<span class="w">  </span>Picture<span class="w">  </span>Public<span class="w">  </span>snap<span class="w">  </span>Video
</pre></div>
</div>
<p>我们可以看见：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>D*
Doc<span class="w"> </span>Downloads
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>*s
Downloads
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="o">[[</span>:upper:<span class="o">]]</span>*
Doc<span class="w"> </span>Downloads<span class="w"> </span>Music<span class="w"> </span>Picture<span class="w"> </span>Public<span class="w"> </span>Video
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>/usr/*/share
/usr/local/share
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls<span class="w"> </span>D*
Doc:
Linux_Basics

Downloads:
</pre></div>
</div>
</section>
<section id="tilde-expansion">
<h3>Tilde Expansion<a class="headerlink" href="#tilde-expansion" title="Link to this heading"></a></h3>
<p>波浪号字符（“<code class="docutils literal notranslate"><span class="pre">~</span></code>”）具有特殊的含义。当在单词开头使用时，它会扩展到指定用户的主目录的名称（expands into the name of the home directory of the named user），如果没有命名用户，则扩展为当前用户的主目录：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>~
/home/shimofang
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>~shimofang
/home/shimofang
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>~shiyaofang
~shiyaofang
</pre></div>
</div>
</section>
<section id="id12">
<h3>算术拓展<a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<p>shell允许通过扩展执行算术。这允许我们使用shell提示符作为计算器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="k">$((</span><span class="nv">expression</span><span class="k">))</span>
</pre></div>
</div>
<p>一些例子：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$((</span><span class="m">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">2</span><span class="k">))</span>
<span class="m">4</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$((</span><span class="m">2</span><span class="o">^</span><span class="m">3</span><span class="o">/</span><span class="m">5</span><span class="o">+</span><span class="m">12</span><span class="k">))</span>
<span class="m">14</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$((</span><span class="m">99</span>.3<span class="k">))</span>
bash:<span class="w"> </span><span class="m">99</span>.3:<span class="w"> </span>syntax<span class="w"> </span>error:<span class="w"> </span>invalid<span class="w"> </span>arithmetic<span class="w"> </span>operator<span class="w"> </span><span class="o">(</span>error<span class="w"> </span>token<span class="w"> </span>is<span class="w"> </span><span class="s2">&quot;.3&quot;</span><span class="o">)</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$((</span><span class="m">100</span><span class="o">/</span><span class="m">99</span><span class="k">))</span>
<span class="m">1</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$(($((</span><span class="m">5</span><span class="o">**</span><span class="m">2</span><span class="k">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">3</span><span class="k">))</span>
<span class="m">75</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>Five<span class="w"> </span>divided<span class="w"> </span>by<span class="w"> </span>two<span class="w"> </span>equals<span class="w"> </span><span class="k">$((</span><span class="m">5</span><span class="o">/</span><span class="m">2</span><span class="k">))</span>
Five<span class="w"> </span>divided<span class="w"> </span>by<span class="w"> </span>two<span class="w"> </span>equals<span class="w"> </span><span class="m">2</span>
</pre></div>
</div>
</section>
<section id="brace-expansion">
<h3>Brace Expansion<a class="headerlink" href="#brace-expansion" title="Link to this heading"></a></h3>
<p>我们可以从包含大括号的模式创建多个文本字符串。这里有一个例子：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>Front-<span class="o">{</span>A,B,C<span class="o">}</span>-Back
Front-A-Back<span class="w"> </span>Front-B-Back<span class="w"> </span>Front-C-Back
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>我<span class="o">{</span>上午,中午,下午<span class="o">}</span>在睡觉
我上午在睡觉<span class="w"> </span>我中午在睡觉<span class="w"> </span>我下午在睡觉
</pre></div>
</div>
<p>要展开大括号的模式可能包含称为序言（preamble）的开头部分（leading portion）和称为后记（trailing）的尾部部分（postscript）。括号表达式本身可以包含逗号<code class="docutils literal notranslate"><span class="pre">,</span></code>分隔的字符串列表，也可以包含整数或单个字符的范围。该模式可能不包含嵌入式空格（embedded whitespace）。</p>
<p>使用一系列整数的示例：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>伞兵<span class="o">{</span><span class="m">1</span>..3<span class="o">}</span>号
伞兵1号<span class="w"> </span>伞兵2号<span class="w"> </span>伞兵3号
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>Number_<span class="o">{</span><span class="m">5</span>..1<span class="o">}</span>
Number_5<span class="w"> </span>Number_4<span class="w"> </span>Number_3<span class="w"> </span>Number_2<span class="w"> </span>Number_1
</pre></div>
</div>
<p>反向顺序的字母：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="o">{</span>Z..A<span class="o">}</span>
Z<span class="w"> </span>Y<span class="w"> </span>X<span class="w"> </span>W<span class="w"> </span>V<span class="w"> </span>U<span class="w"> </span>T<span class="w"> </span>S<span class="w"> </span>R<span class="w"> </span>Q<span class="w"> </span>P<span class="w"> </span>O<span class="w"> </span>N<span class="w"> </span>M<span class="w"> </span>L<span class="w"> </span>K<span class="w"> </span>J<span class="w"> </span>I<span class="w"> </span>H<span class="w"> </span>G<span class="w"> </span>F<span class="w"> </span>E<span class="w"> </span>D<span class="w"> </span>C<span class="w"> </span>B<span class="w"> </span>A
</pre></div>
</div>
<p>Brace Expansion可以嵌套：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>a<span class="o">{</span>A<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>,B<span class="o">{</span><span class="m">3</span>,4<span class="o">}}</span>b
aA1b<span class="w"> </span>aA2b<span class="w"> </span>aB3b<span class="w"> </span>aB4b
</pre></div>
</div>
<p>那么这有什么好处呢？最常见的应用是<strong>制作要创建的文件或目录列表</strong>。例如，如果我们是一名摄影师，并且有大量想要组织成几年和几个月的图像，我们可能做的第一件事就是创建一系列以数字“年-月”格式命名的目录。这样，目录名称将按时间顺序排序:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/home/shimofang/P*e
shimofang@shimofang-virtual-machine:~/Picture$<span class="w"> </span>mkdir<span class="w"> </span>Photos_tset
shimofang@shimofang-virtual-machine:~/Picture$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>P*
shimofang@shimofang-virtual-machine:~/Picture/Photos_tset$<span class="w"> </span>mkdir<span class="w"> </span><span class="o">{</span><span class="m">2020</span>..2023<span class="o">}</span>-<span class="o">{</span><span class="m">1</span>..12<span class="o">}</span>
shimofang@shimofang-virtual-machine:~/Picture/Photos_tset$<span class="w"> </span>ls
<span class="m">2020</span>-1<span class="w">   </span><span class="m">2020</span>-2<span class="w">  </span><span class="m">2020</span>-6<span class="w">  </span><span class="m">2021</span>-1<span class="w">   </span><span class="m">2021</span>-2<span class="w">  </span><span class="m">2021</span>-6<span class="w">  </span><span class="m">2022</span>-1<span class="w">   </span><span class="m">2022</span>-2<span class="w">  </span><span class="m">2022</span>-6<span class="w">  </span><span class="m">2023</span>-1<span class="w">   </span><span class="m">2023</span>-2<span class="w">  </span><span class="m">2023</span>-6
<span class="m">2020</span>-10<span class="w">  </span><span class="m">2020</span>-3<span class="w">  </span><span class="m">2020</span>-7<span class="w">  </span><span class="m">2021</span>-10<span class="w">  </span><span class="m">2021</span>-3<span class="w">  </span><span class="m">2021</span>-7<span class="w">  </span><span class="m">2022</span>-10<span class="w">  </span><span class="m">2022</span>-3<span class="w">  </span><span class="m">2022</span>-7<span class="w">  </span><span class="m">2023</span>-10<span class="w">  </span><span class="m">2023</span>-3<span class="w">  </span><span class="m">2023</span>-7
<span class="m">2020</span>-11<span class="w">  </span><span class="m">2020</span>-4<span class="w">  </span><span class="m">2020</span>-8<span class="w">  </span><span class="m">2021</span>-11<span class="w">  </span><span class="m">2021</span>-4<span class="w">  </span><span class="m">2021</span>-8<span class="w">  </span><span class="m">2022</span>-11<span class="w">  </span><span class="m">2022</span>-4<span class="w">  </span><span class="m">2022</span>-8<span class="w">  </span><span class="m">2023</span>-11<span class="w">  </span><span class="m">2023</span>-4<span class="w">  </span><span class="m">2023</span>-8
<span class="m">2020</span>-12<span class="w">  </span><span class="m">2020</span>-5<span class="w">  </span><span class="m">2020</span>-9<span class="w">  </span><span class="m">2021</span>-12<span class="w">  </span><span class="m">2021</span>-5<span class="w">  </span><span class="m">2021</span>-9<span class="w">  </span><span class="m">2022</span>-12<span class="w">  </span><span class="m">2022</span>-5<span class="w">  </span><span class="m">2022</span>-9<span class="w">  </span><span class="m">2023</span>-12<span class="w">  </span><span class="m">2023</span>-5<span class="w">  </span><span class="m">2023</span>-9
</pre></div>
</div>
</section>
<section id="parameter-expansion">
<h3>参数扩展（Parameter Expansion）<a class="headerlink" href="#parameter-expansion" title="Link to this heading"></a></h3>
<p>这是一个在shell脚本中比直接在命令行上更有用的功能。它的许多功能都与系统存储小块数据并给每个块命名的能力有关。许多这样的块，更恰当地称为变量（variables），可供我们检查。例如，名为“<code class="docutils literal notranslate"><span class="pre">USER</span></code>”的变量包含我们的用户名。要调用参数扩展并显示USER的内容，我们将这样做：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$USER</span>
shimofang
</pre></div>
</div>
<p>要查看可用变量的列表，请尝试以下方法：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>printenv<span class="w"> </span><span class="p">|</span><span class="w"> </span>less
</pre></div>
</div>
<p>对于其他类型的扩展，如果我们键入错误的模式，扩展将不会发生，<code class="docutils literal notranslate"><span class="pre">echo</span></code>命令将简单地显示键入错误的模式。使用参数扩展，如果我们拼错变量的名称，扩展仍将发生，但将导致空字符串。</p>
</section>
<section id="command-substitution">
<h3>命令替换（Command Substitution）<a class="headerlink" href="#command-substitution" title="Link to this heading"></a></h3>
<p>命令替换允许我们使用命令的输出作为扩展：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$(</span>ls<span class="k">)</span>
模板<span class="w"> </span>桌面<span class="w"> </span>Doc<span class="w"> </span>Downloads<span class="w"> </span>Music<span class="w"> </span>Picture<span class="w"> </span>Public<span class="w"> </span>snap<span class="w"> </span>Video
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span><span class="k">$(</span>which<span class="w"> </span>cp<span class="k">)</span>
-rwxr-xr-x<span class="w"> </span><span class="m">1</span><span class="w"> </span>root<span class="w"> </span>root<span class="w"> </span><span class="m">141824</span><span class="w">  </span>2月<span class="w">  </span><span class="m">8</span><span class="w">  </span><span class="m">2022</span><span class="w"> </span>/usr/bin/cp
</pre></div>
</div>
<p>在这里，我们将<code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">cp</span></code>作为参数的结果传递给<code class="docutils literal notranslate"><span class="pre">ls</span></code>命令，从而获得<code class="docutils literal notranslate"><span class="pre">cp</span></code>程序的列表，而不必知道其完整的路径名。我们不仅限于简单的命令。可以使用整个管道（Entire pipelines）（仅显示部分输出）：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>file<span class="w"> </span><span class="k">$(</span>ls<span class="w"> </span>/usr/bin/*<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>bin/zip<span class="k">)</span>
/usr/bin/zip:<span class="w">        </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>pie<span class="w"> </span>executable,<span class="w"> </span>x86-64,<span class="w"> </span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>dynamically<span class="w"> </span>linked,<span class="w"> </span>interpreter<span class="w"> </span>/lib64/ld-linux-x86-64.so.2,<span class="w"> </span>BuildID<span class="o">[</span>sha1<span class="o">]=</span>f4e3c129a9a184aecb256650d23ed3d92bcd60db,<span class="w"> </span><span class="k">for</span><span class="w"> </span>GNU/Linux<span class="w"> </span><span class="m">3</span>.2.0,<span class="w"> </span>stripped
/usr/bin/zipcloak:<span class="w">   </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>pie<span class="w"> </span>executable,<span class="w"> </span>x86-64,<span class="w"> </span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>dynamically<span class="w"> </span>linked,<span class="w"> </span>interpreter<span class="w"> </span>/lib64/ld-linux-x86-64.so.2,<span class="w"> </span>BuildID<span class="o">[</span>sha1<span class="o">]=</span>754f1c0c2e6121523bd6aa727edda9ba78a412bc,<span class="w"> </span><span class="k">for</span><span class="w"> </span>GNU/Linux<span class="w"> </span><span class="m">3</span>.2.0,<span class="w"> </span>stripped
/usr/bin/zipdetails:<span class="w"> </span>Perl<span class="w"> </span>script<span class="w"> </span>text<span class="w"> </span>executable
/usr/bin/zipgrep:<span class="w">    </span>POSIX<span class="w"> </span>shell<span class="w"> </span>script,<span class="w"> </span>ASCII<span class="w"> </span>text<span class="w"> </span>executable
</pre></div>
</div>
<p>在本例中，管道的结果成为文件命令的参数列表。在较旧的shell程序中有一个命令替换的替代语法，bash也支持该语法。它使用反向引号而不是美元符号和括号：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span><span class="sb">`</span>which<span class="w"> </span>cp<span class="sb">`</span>
-rwxr-xr-x<span class="w"> </span><span class="m">1</span><span class="w"> </span>root<span class="w"> </span>root<span class="w"> </span><span class="m">141824</span><span class="w">  </span>2月<span class="w">  </span><span class="m">8</span><span class="w">  </span><span class="m">2022</span><span class="w"> </span>/usr/bin/cp
</pre></div>
</div>
</section>
<section id="quoting">
<h3>引用（Quoting）<a class="headerlink" href="#quoting" title="Link to this heading"></a></h3>
<p>观察示例：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>this<span class="w"> </span>is<span class="w"> </span>a<span class="w">     </span><span class="nb">test</span>
this<span class="w"> </span>is<span class="w"> </span>a<span class="w"> </span><span class="nb">test</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>The<span class="w"> </span>total<span class="w"> </span>is<span class="w"> </span><span class="nv">$100</span>.00
The<span class="w"> </span>total<span class="w"> </span>is<span class="w"> </span><span class="m">00</span>.00
</pre></div>
</div>
<p>在第一个示例中，shell的单词拆分从<code class="docutils literal notranslate"><span class="pre">echo</span></code>命令的参数列表中删除了额外的空格。</p>
<p>在第二个示例中，参数扩展用空字符串替换了“$1”的值，因为它是一个未定义的变量。shell提供了一种称为引用（quoting）的机制，以选择性地抑制不需要的扩展（suppress unwanted expansions）。</p>
<p><strong>双引号（Double Quotes）</strong>
如果我们把文本放在双引号中，shell使用的所有特殊字符都会失去其特殊意义，并被视为普通字符。例外是“$”、“\”（反斜杠）和“`”（反引号）。这意味着单词拆分、路径名扩展、波浪号扩展和大括号扩展被抑制，但参数扩展、算术扩展和命令替换仍然被执行。</p>
<p>使用双引号，我们可以处理<strong>包含嵌入式空格</strong>的文件名。想象一下，我们是一个名为two words.txt的文件的不幸受害者。如果我们试图在命令行上使用它，单词拆分将导致将其视为两个单独的参数，而不是所需的单个参数。</p>
<p><strong>Q：如何创建带有空格的文件？</strong></p>
<p>现在我们不必一直输入那些讨厌的双引号了。请记住，参数扩展、算术扩展和命令替换仍然在双引号中进行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$USER</span><span class="s2"> </span><span class="k">$((</span><span class="m">2</span><span class="o">+</span><span class="m">2</span><span class="k">))</span><span class="s2">&quot;</span>
shimofang<span class="w"> </span><span class="m">4</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$USER</span><span class="w"> </span><span class="k">$((</span><span class="m">2</span><span class="o">+</span><span class="m">2</span><span class="k">))</span>
shimofang<span class="w"> </span><span class="m">4</span>
</pre></div>
</div>
<p>我们应该花点时间看看双引号对命令替换的影响。首先，让我们更深入地看看单词拆分是如何工作的（how word splitting works）。在我们之前的例子中，我们看到了单词拆分如何删除文本中的额外空格：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>this<span class="w"> </span>is<span class="w"> </span>a<span class="w">     </span><span class="nb">test</span>
this<span class="w"> </span>is<span class="w"> </span>a<span class="w"> </span><span class="nb">test</span>
</pre></div>
</div>
<p>默认情况下，单词拆分查找空格、制表符和换行符（换行符）的存在，并将其视为单词之间的分隔符。这意味着未引用的空格、制表符和换行符不被视为文本的一部分。它们仅作为分隔符。由于它们将单词分成不同的参数，我们的示例命令行包含一个命令，后跟四个不同的参数。如果我们添加双引号：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;this is a     test&quot;</span>
this<span class="w"> </span>is<span class="w"> </span>a<span class="w">     </span><span class="nb">test</span>
</pre></div>
</div>
<p>单词拆分被抑制，嵌入的空格不被视为分隔符，而是它们成为参数的一部分。添加双引号后，我们的命令行将包含一个命令，后跟一个参数。换行符被单词拆分机制视为分隔符。</p>
<p><strong>单引号（Single Quotes）</strong></p>
<p>当我们需要抑制所有扩展时，我们使用单引号。以下是未引用、双引号和单引号的比较：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>text<span class="w"> </span>~/*.txt<span class="w"> </span><span class="o">{</span>a,b<span class="o">}</span><span class="w"> </span><span class="k">$(</span><span class="nb">echo</span><span class="w"> </span>foo<span class="k">)</span><span class="w"> </span><span class="k">$((</span><span class="m">2</span><span class="o">+</span><span class="m">2</span><span class="k">))</span><span class="w"> </span><span class="nv">$USER</span>
text<span class="w"> </span>/home/shimofang/*.txt<span class="w"> </span>a<span class="w"> </span>b<span class="w"> </span>foo<span class="w"> </span><span class="m">4</span><span class="w"> </span>shimofang
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;text ~/*.txt {a,b} </span><span class="k">$(</span><span class="nb">echo</span><span class="w"> </span>foo<span class="k">)</span><span class="s2"> </span><span class="k">$((</span><span class="m">2</span><span class="o">+</span><span class="m">2</span><span class="k">))</span><span class="s2"> </span><span class="nv">$USER</span><span class="s2">&quot;</span>
text<span class="w"> </span>~/*.txt<span class="w"> </span><span class="o">{</span>a,b<span class="o">}</span><span class="w"> </span>foo<span class="w"> </span><span class="m">4</span><span class="w"> </span>shimofang
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&#39;</span>
text<span class="w"> </span>~/*.txt<span class="w"> </span><span class="o">{</span>a,b<span class="o">}</span><span class="w"> </span><span class="k">$(</span><span class="nb">echo</span><span class="w"> </span>foo<span class="k">)</span><span class="w"> </span><span class="k">$((</span><span class="m">2</span><span class="o">+</span><span class="m">2</span><span class="k">))</span><span class="w"> </span><span class="nv">$USER</span>
</pre></div>
</div>
</section>
<section id="escaping-characters">
<h3>转义字符（Escaping Characters）<a class="headerlink" href="#escaping-characters" title="Link to this heading"></a></h3>
<p>有时我们只想引用一个字符。要做到这一点，我们可以在字符之前加反斜杠<code class="docutils literal notranslate"><span class="pre">\</span></code>，在此上下文中，反斜杠被称为转义字符。这通常是在双引号内完成的，以便有选择地防止扩展。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;The balance for user </span><span class="nv">$USER</span><span class="s2"> is: \$5.00&quot;</span>
The<span class="w"> </span>balance<span class="w"> </span><span class="k">for</span><span class="w"> </span>user<span class="w"> </span>shimofang<span class="w"> </span>is:<span class="w"> </span><span class="nv">$5</span>.00
</pre></div>
</div>
<p>使用转义来消除文件名中字符的特殊含义也很常见。例如，可以在文件名中使用通常对shell具有特殊意义的字符。这些将包括“<code class="docutils literal notranslate"><span class="pre">$</span></code>”、“<code class="docutils literal notranslate"><span class="pre">!</span></code>”、“<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>”等。要在文件名中包含一个特殊字符，我们可以这样做：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mv<span class="w"> </span>bad<span class="se">\&amp;</span>filename<span class="w"> </span>good_filename
</pre></div>
</div>
<p>要允许反斜杠字符出现，请键入“\\”来转义它。请注意，在单引号中，反斜杠失去了其特殊含义，并被视为普通字符。</p>
</section>
<section id="backslash-tricks">
<h3>反斜线技巧（Backslash Tricks）<a class="headerlink" href="#backslash-tricks" title="Link to this heading"></a></h3>
<p>如果我们查看<a class="reference external" href="http://www.gnu.org/">GNU项目</a>编写的任何程序的手册页，我们会发现，除了由破折号和单个字母组成的命令行选项外，还有以两个破折号开头的长选项名称。例如，以下是等价的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ls</span> <span class="o">-</span><span class="n">r</span>
<span class="n">ls</span> <span class="o">--</span><span class="n">reverse</span>
</pre></div>
</div>
<p>为什么支持两者？</p>
<p>短形式适用于命令行上的懒惰打字员，长形式主要适用于脚本（scripts），尽管一些选项可能仅以长形式提供。有时，当选项模糊不清时，<strong>最好使用长选项</strong>。在编写需要最大可读性的脚本时，这尤其有用。</p>
<p>使用长表单选项可以使单个命令行非常长。为了解决这个问题，我们可以使用反斜杠让shell忽略像这样的换行符：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ls</span> <span class="o">-</span><span class="n">l</span> \
   <span class="o">--</span><span class="n">reverse</span> \
   <span class="o">--</span><span class="n">human</span><span class="o">-</span><span class="n">readable</span> \
   <span class="o">--</span><span class="n">full</span><span class="o">-</span><span class="n">time</span>
</pre></div>
</div>
<p>以这种方式使用反斜杠允许我们在命令中嵌入换行符。请注意，要使这个技巧发挥作用，必须在反斜杠后立即键入换行。</p>
<p>反斜杠也用于在我们的文本中插入特殊字符。这些被称为反斜杠转义字符：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>转义字符</th>
<th>名字</th>
<th>可能的用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>新行</td>
<td>文本中添加空白行</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
<td>在文本中插入水平制表符</td>
</tr>
<tr>
<td>\a</td>
<td>警告</td>
<td>发出我们的终端蜂鸣声</td>
</tr>
<tr>
<td>\</td>
<td>反斜线</td>
<td>插入反斜杠</td>
</tr>
<tr>
<td>\f</td>
<td>formfeed</td>
<td>将此发送到我们的打印机会弹出页面</td>
</tr>
</tbody>
</table><p>使用反斜杠转义字符非常常见。这个想法首次出现在C编程语言中。今天，shell、C++、Perl、python、awk、tcl和许多其他编程语言都使用这个概念。将echo命令与-e选项（启用反斜杠转义的解释）一起使用：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>-e<span class="w"> </span><span class="s2">&quot;Inserting several blank lines\n\n\n&quot;</span>
Inserting<span class="w"> </span>several<span class="w"> </span>blank<span class="w"> </span>lines
-------line-------
-------line-------
-------line-------
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>-e<span class="w"> </span><span class="s2">&quot;Words\tseparated\tby\thorizontal\ttabs.&quot;</span>
Words<span class="w">	</span>separated<span class="w">	</span>by<span class="w">	</span>horizontal<span class="w">	</span>tabs.
</pre></div>
</div>
</section>
</section>
<section id="permissions">
<h2>九、权限（Permissions）<a class="headerlink" href="#permissions" title="Link to this heading"></a></h2>
<p>类Unix操作系统，如Linux，与其他计算系统的不同之处在于，它们不仅是多任务处理，而且是多用户。这意味着多个用户可以同时操作计算机。虽然台式机或笔记本电脑只有一个键盘和显示器，但它仍然可以由多个用户使用。</p>
<p>例如，如果计算机连接到网络（network）或互联网（Internet），远程用户可以通过<code class="docutils literal notranslate"><span class="pre">ssh</span></code>（secure shell）登录并操作计算机。事实上，远程用户可以执行图形应用程序，并将输出显示在远程计算机上。<a class="reference external" href="https://blog.csdn.net/lendq/article/details/78555257">X Window系统</a>支持这个。</p>
<p>类Unix系统的多用户能力是操作系统设计中根深蒂固的功能。在计算机成为“个人的”之前，它们是大型、昂贵和集中的。一个典型的大学计算机系统由位于校园内一些大楼的大型大型计算机组成，终端位于整个校园，每个终端都连接到大型中央计算机。计算机将同时支持许多用户。</p>
<p>为了使其实用，必须设计一种方法来保护用户免受彼此的伤害。毕竟，我们不希望一个用户的操作使计算机崩溃，也不允许一个用户干扰属于另一个用户的文件。</p>
<p>本章将涵盖以下命令：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">chmod</span></code> - 修改文件访问权限</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">su</span></code> - 暂时成为超级用户</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sudo</span></code> - 暂时成为超级用户</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chown</span></code> - 更改文件所有权</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chgrp</span></code> - 更改文件的组所有权</p></li>
</ul>
<section id="file-permissions">
<h3>文件权限（File Permissions）<a class="headerlink" href="#file-permissions" title="Link to this heading"></a></h3>
<p>在Linux系统上，每个文件和目录都为文件所有者、一组相关用户的成员以及其他人分配了访问权限。可以分配读取文件、写入文件和执行文件（即将文件作为程序运行）的权限。</p>
<p>要查看文件的权限设置，我们可以使用ls命令。例如，我们将查看位于<code class="docutils literal notranslate"><span class="pre">/bin</span></code>目录中的<code class="docutils literal notranslate"><span class="pre">bash</span></code>程序：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>/bin/bash
-rwxr-xr-x<span class="w"> </span><span class="m">1</span><span class="w"> </span>root<span class="w"> </span>root<span class="w"> </span><span class="m">1396520</span><span class="w">  </span>1月<span class="w">  </span><span class="m">7</span><span class="w">  </span><span class="m">2022</span><span class="w"> </span>/bin/bash
</pre></div>
</div>
<p>在这里，我们可以看到：</p>
<ul class="simple">
<li><p>文件“<code class="docutils literal notranslate"><span class="pre">/bin/bash</span></code>”归用户“<code class="docutils literal notranslate"><span class="pre">root</span></code>”所有</p></li>
<li><p>超级用户有权读取、写入和执行此文件</p></li>
<li><p>该文件归“<code class="docutils literal notranslate"><span class="pre">root</span></code>”组所有</p></li>
<li><p>组“<code class="docutils literal notranslate"><span class="pre">root</span></code>”的成员也可以读取和执行此文件</p></li>
<li><p>其他人都可以读取并执行此文件</p></li>
</ul>
<p>在下面的图表中，我们看到了输出的第一部分<code class="docutils literal notranslate"><span class="pre">-rwxr-xr-x</span></code>是如何解释的：它由一个指示文件类型的字符组成，后跟三组三个字符，传达所有者、组和其他人的读取、写入和执行权限。</p>
<p><img alt="文件权限" src="_images/linux_basic_permissions_c9_fig_1.png" /></p>
</section>
<section id="chmod">
<h3><code class="docutils literal notranslate"><span class="pre">chmod</span></code><a class="headerlink" href="#chmod" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">chmod</span></code>命令用于更改文件或目录的权限。要使用它，我们指定所需的权限设置和我们希望修改的一个或多个文件。有两种方法可以指定权限。在本课中，我们将重点讨论其中一种，称为<strong>八进制表示法</strong>。</p>
<p>很容易将权限设置视为一系列位（bits），它的工作原理如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rwx</span> <span class="n">rwx</span> <span class="n">rwx</span> <span class="o">=</span> <span class="mi">111</span> <span class="mi">111</span> <span class="mi">111</span>
<span class="n">rw</span><span class="o">-</span> <span class="n">rw</span><span class="o">-</span> <span class="n">rw</span><span class="o">-</span> <span class="o">=</span> <span class="mi">110</span> <span class="mi">110</span> <span class="mi">110</span>
<span class="n">rwx</span> <span class="o">---</span> <span class="o">---</span> <span class="o">=</span> <span class="mi">111</span> <span class="mi">000</span> <span class="mi">000</span>

<span class="ow">and</span> <span class="n">so</span> <span class="n">on</span><span class="o">...</span>

<span class="n">rwx</span> <span class="o">=</span> <span class="mi">111</span> <span class="ow">in</span> <span class="n">binary</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">rw</span><span class="o">-</span> <span class="o">=</span> <span class="mi">110</span> <span class="ow">in</span> <span class="n">binary</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">r</span><span class="o">-</span><span class="n">x</span> <span class="o">=</span> <span class="mi">101</span> <span class="ow">in</span> <span class="n">binary</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">r</span><span class="o">--</span> <span class="o">=</span> <span class="mi">100</span> <span class="ow">in</span> <span class="n">binary</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>现在，如果我们把三组权限（所有者、组和其他）中的每组都表示为一个数字，我们就有一种非常方便的方式来表达可能的权限设置。例如，如果我们想将some_file设置为所有者的读写权限，但想对其他人保持文件的私密性，我们会：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">chmod</span> <span class="mi">600</span> <span class="n">some_file</span>
</pre></div>
</div>
<p>下面一张数字表，涵盖了所有常见设置。以“7”开头的用于程序（因为它们允许执行），其余的用于其他类型的文件。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>777</td>
<td>（rwxrwxrwx）对权限没有限制。任何人都可以做任何事情。通常不是一个理想的设置。</td>
</tr>
<tr>
<td>755</td>
<td>（rwxr-xr-x）文件的所有者可以读取、写入和执行文件。所有其他人都可以读取和执行文件。此设置适用于所有用户使用的程序。</td>
</tr>
<tr>
<td>700</td>
<td>（rwx------）文件的所有者可以读取、写入和执行文件。没有其他人拥有任何权利。此设置对只有所有者才能使用的程序很有用，并且必须对其他人保密。</td>
</tr>
<tr>
<td>666</td>
<td>（rw-rw-rw-）所有用户都可以读写文件。</td>
</tr>
<tr>
<td>644</td>
<td>（rw-r--r--）所有者可以读取和写入文件，而所有其他人只能读取文件。每个人都可以读取的数据文件的常见设置，但只有所有者可以更改。</td>
</tr>
<tr>
<td>600</td>
<td>（rw-------）所有者可以读取和写入文件。所有其他人都没有权利。所有者希望保持私密的数据文件的常见设置。</td>
</tr>
</tbody>
</table></section>
<section id="directory-permissions">
<h3>目录权限（Directory Permissions）<a class="headerlink" href="#directory-permissions" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">chmod</span></code>命令也可用于控制目录的访问权限。同样，我们可以使用八进制表示法来设置权限，但<code class="docutils literal notranslate"><span class="pre">r</span></code>、<code class="docutils literal notranslate"><span class="pre">w</span></code>和<code class="docutils literal notranslate"><span class="pre">x</span></code>属性的含义不同：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> - 如果还设置了x属性，则允许列出目录的内容。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> - 如果还设置了x属性，则允许创建、删除或重命名目录中的文件。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> - 允许进入目录（即<code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">dir</span></code>）。</p></li>
</ul>
</section>
<section id="becoming-the-superuser-for-a-short-while">
<h3>暂时成为超级用户（Becoming the Superuser for a Short While）<a class="headerlink" href="#becoming-the-superuser-for-a-short-while" title="Link to this heading"></a></h3>
<p>通常有必要成为超级用户来执行重要的系统管理任务，但正如我们所知，我们不应该以超级用户的身份保持登录状态。</p>
<p>在大多数发行版中，有一个程序可以让您临时访问超级用户的权限。这个程序被称为su（substitute user的缩写），可以在您需要成为少量任务的超级用户时使用。要成为超级用户，只需键入su命令。系统将提示您输入超级用户的密码：</p>
<p>执行su命令后，我们有一个新的shell会话作为超级用户。要退出超级用户会话，请键入exit，我们将返回您之前的会话。</p>
<p>在大多数现代分布（modern distributions）中，使用替代方法。这些系统不使用<code class="docutils literal notranslate"><span class="pre">su</span></code>，而是使用<code class="docutils literal notranslate"><span class="pre">sudo</span></code>命令。使用<code class="docutils literal notranslate"><span class="pre">sudo</span></code>，一个或多个用户根据需要被授予超级用户权限。</p>
<p>要作为超级用户执行命令，所需的命令只需在<code class="docutils literal notranslate"><span class="pre">sudo</span></code>命令之前。输入命令后，系统会提示用户输入自己的密码，而不是超级用户的密码。</p>
<p>事实上，现代发行版甚至没有设置根帐户密码，因此无法以根用户身份登录。通过使用“-i”选项，sudo仍然可以使用root shell。</p>
</section>
<section id="changing-file-ownership">
<h3>更改文件所有权（Changing File Ownership）<a class="headerlink" href="#changing-file-ownership" title="Link to this heading"></a></h3>
<p>我们可以使用<code class="docutils literal notranslate"><span class="pre">chown</span></code>命令更改文件的所有者。这里有一个例子：假设我们想将some_file的所有者从“我”更改为“你”。我们可以：</p>
<p><code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">chown</span> <span class="pre">you</span> <span class="pre">some_file</span></code></p>
<p>请注意，<strong>要更改文件的所有者，我们必须拥有超级用户权限。</strong> 为了做到这一点，我们的例子使用了<code class="docutils literal notranslate"><span class="pre">sudo</span></code>命令来执行<code class="docutils literal notranslate"><span class="pre">chown</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">chown</span></code>在目录上的工作方式与在文件上的工作方式相同。</p>
</section>
<section id="changing-group-ownership">
<h3>改变组的所有权（Changing Group Ownership）<a class="headerlink" href="#changing-group-ownership" title="Link to this heading"></a></h3>
<p>文件或目录的组所有权可以通过<code class="docutils literal notranslate"><span class="pre">chgrp</span></code>更改。这个命令是这样使用的：</p>
<p><code class="docutils literal notranslate"><span class="pre">chgrp</span> <span class="pre">new_group</span> <span class="pre">some_file</span></code></p>
<p>在上面的示例中，我们将<code class="docutils literal notranslate"><span class="pre">some_file</span></code>的组所有权从之前的组更改为“<code class="docutils literal notranslate"><span class="pre">new_group</span></code>”。我们必须是<strong>文件或目录的所有者</strong>才能执行<code class="docutils literal notranslate"><span class="pre">chgrp</span></code>。</p>
</section>
</section>
<section id="job-control">
<h2>十、控制工作（Job Control）<a class="headerlink" href="#job-control" title="Link to this heading"></a></h2>
<p>在章我们将研究Linux的多任务处理性质，以及如何通过命令行界面（command line interface）对其进行控制。</p>
<p>与任何多任务操作系统一样，Linux同时执行多个进程。实际上，单个处理器内核一次只能执行一个进程，但Linux内核设法让每个进程在处理器上轮到它，并且每个进程似乎同时运行。</p>
<p>有几个命令用于控制进程。它们是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ps</span></code> - 列出系统上运行的进程</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kill</span></code> - 向一个或多个进程发送信号（通常是为了“杀死”一个进程）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jobs</span></code> - 列出您自己的流程的另一种方式</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bg</span></code> - 将一个过程放在后台</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fg</span></code> - 将一个过程放在前台</p></li>
</ul>
<section id="id13">
<h3>一个实例<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<p>虽然这个主题似乎相当晦涩难懂，但对于主要使用图形用户界面的普通用户来说，它可能非常实用。虽然可能不明显，但大多数图形程序都可以从命令行启动。</p>
<p>这里有一个例子：有一个名为<code class="docutils literal notranslate"><span class="pre">xload</span></code>的X Window系统附带的小程序，它显示一个表示系统负载的图表。我们可以通过键入以下内容来执行此程序：</p>
<p><code class="docutils literal notranslate"><span class="pre">xload</span></code></p>
<p>请注意，<code class="docutils literal notranslate"><span class="pre">xload</span></code>窗口出现并开始显示系统负载图。在<code class="docutils literal notranslate"><span class="pre">xload</span></code>不可用的系统上，请尝试<code class="docutils literal notranslate"><span class="pre">gedit</span></code>。另请注意，在程序启动后，我们的提示没有再次出现。在控件返回之前，shell正在等待程序完成。如果我们关闭<code class="docutils literal notranslate"><span class="pre">xload</span></code>窗口，<code class="docutils literal notranslate"><span class="pre">xload</span></code>程序将终止并返回提示。</p>
</section>
<section id="putting-a-program-into-the-background">
<h3>将程序放入后台（Putting a Program into the Background）<a class="headerlink" href="#putting-a-program-into-the-background" title="Link to this heading"></a></h3>
<p>现在，为了让生活更轻松一点，我们将再次启动xload程序，但这次我们将把它放在后台，以便提示返回。为此，我们像这样执行xload：</p>
<p><code class="docutils literal notranslate"><span class="pre">xload</span> <span class="pre">&amp;</span></code></p>
<p>在这种情况下，提示返回，因为该过程被置于后台。</p>
<p>除了使用“&amp;”符号将程序放入后台，我们可以键入<code class="docutils literal notranslate"><span class="pre">Ctrl-z</span></code>使该过程将被暂停。我们可以通过看到程序的窗口被冻结来验证这一点。这个过程仍然存在，但却闲置。要在后台恢复进程，请键入<code class="docutils literal notranslate"><span class="pre">bg</span></code>命令（background的缩写）。</p>
</section>
<section id="listing-running-processes">
<h3>列出正在运行的进程（Listing Running Processes）<a class="headerlink" href="#listing-running-processes" title="Link to this heading"></a></h3>
<p>我们可以使用<code class="docutils literal notranslate"><span class="pre">jobs</span></code>命令或更强大的<code class="docutils literal notranslate"><span class="pre">ps</span></code>命令列出正在运行的进程：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>xload
^Z
<span class="o">[</span><span class="m">1</span><span class="o">]</span>+<span class="w">  </span>Stopped<span class="w">                 </span>xload
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>gedit
^Z
<span class="o">[</span><span class="m">2</span><span class="o">]</span>+<span class="w">  </span>Stopped<span class="w">                 </span>gedit
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">jobs</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span>-<span class="w">  </span>Stopped<span class="w">                 </span>xload
<span class="o">[</span><span class="m">2</span><span class="o">]</span>+<span class="w">  </span>Stopped<span class="w">                 </span>gedit
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ps
<span class="w">    </span>PID<span class="w"> </span>TTY<span class="w">          </span>TIME<span class="w"> </span>CMD
<span class="w">   </span><span class="m">7167</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>bash
<span class="w">   </span><span class="m">7465</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>xload
<span class="w">   </span><span class="m">7486</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>gedit
<span class="w">   </span><span class="m">7510</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>ps
</pre></div>
</div>
</section>
<section id="killing-a-process">
<h3>杀死进程（Killing a Process）<a class="headerlink" href="#killing-a-process" title="Link to this heading"></a></h3>
<p>假设有一个程序变得没有响应，使用<code class="docutils literal notranslate"><span class="pre">kill</span></code>命令。</p>
<p>首先，我们需要确定我们想要杀死的过程。我们可以使用<code class="docutils literal notranslate"><span class="pre">jobs</span></code>或<code class="docutils literal notranslate"><span class="pre">ps</span></code>来做这件事。如果我们使用<code class="docutils literal notranslate"><span class="pre">jobs</span></code>，我们会得到一个工作编号（job number）。使用<code class="docutils literal notranslate"><span class="pre">ps</span></code>，我们得到了一个进程ID（PID）：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~$<span class="w"> </span>xload<span class="w"> </span><span class="p">&amp;</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span><span class="w"> </span><span class="m">7612</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>gedit<span class="w"> </span><span class="p">&amp;</span>
<span class="o">[</span><span class="m">2</span><span class="o">]</span><span class="w"> </span><span class="m">7613</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">jobs</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span>-<span class="w">  </span>Running<span class="w">                 </span>xload<span class="w"> </span><span class="p">&amp;</span>
<span class="o">[</span><span class="m">2</span><span class="o">]</span>+<span class="w">  </span>Running<span class="w">                 </span>gedit<span class="w"> </span><span class="p">&amp;</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ps
<span class="w">    </span>PID<span class="w"> </span>TTY<span class="w">          </span>TIME<span class="w"> </span>CMD
<span class="w">   </span><span class="m">7603</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>bash
<span class="w">   </span><span class="m">7612</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>xload
<span class="w">   </span><span class="m">7613</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>gedit
<span class="w">   </span><span class="m">7637</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>ps
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">kill</span><span class="w"> </span>%1
<span class="o">[</span><span class="m">1</span><span class="o">]</span>-<span class="w">  </span>Terminated<span class="w">              </span>xload
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">kill</span><span class="w"> </span><span class="m">7613</span>
shimofang@shimofang-virtual-machine:~$<span class="w"> </span><span class="nb">jobs</span>
<span class="o">[</span><span class="m">2</span><span class="o">]</span>+<span class="w">  </span>Terminated<span class="w">              </span>gedit
shimofang@shimofang-virtual-machine:~$<span class="w"> </span>ps
<span class="w">    </span>PID<span class="w"> </span>TTY<span class="w">          </span>TIME<span class="w"> </span>CMD
<span class="w">   </span><span class="m">7603</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>bash
<span class="w">   </span><span class="m">7646</span><span class="w"> </span>pts/0<span class="w">    </span><span class="m">00</span>:00:00<span class="w"> </span>ps
</pre></div>
</div>
</section>
<section id="kill">
<h3>关于<code class="docutils literal notranslate"><span class="pre">kill</span></code><a class="headerlink" href="#kill" title="Link to this heading"></a></h3>
<p>虽然<code class="docutils literal notranslate"><span class="pre">kill</span></code>命令用于“杀死”进程，但其真正目的是向进程发送信号（signals）。大多数时候，信号旨在告诉过程消失，但远不止于此。程序（如果编写得当）监听来自操作系统的信号并响应它们，通常是为了允许一些优雅的终止方法。</p>
<p>例如，文本编辑器（text editor）可能会监听任何指示用户正在注销或计算机正在关机的信号。当它收到此信号时，它可以在退出之前保存正在进行的工作。<code class="docutils literal notranslate"><span class="pre">kill</span></code>命令可以向进程发送各种信号。</p>
<p>键入<code class="docutils literal notranslate"><span class="pre">kill</span> <span class="pre">-l</span></code>将打印它支持的信号列表。许多相当晦涩难懂，但有几个是方便的：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>信号#</th>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>挂断信号。程序可以监听此信号并采取行动。当您关闭终端时，此信号会发送到在终端中运行的进程。</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>中断信号。这个信号被提供给进程来中断它们。程序可以处理此信号并对其进行操作。我们也可以通过在程序运行的终端窗口中键入Ctrl-c直接发出此信号。</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止信号。此信号提供给进程以终止它们。同样，程序可以处理此信号并采取行动。如果没有指定信号，这是kill命令发送的默认信号。</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>杀死信号。此信号导致Linux内核立即终止该进程。程序无法监听此信号。</td>
</tr>
</tbody>
</table><p>使用格式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kill</span> <span class="o">-</span><span class="n">SIGTERM</span> <span class="mi">2931</span>
<span class="n">kill</span> <span class="o">-</span><span class="mi">9</span> <span class="mi">2931</span>
<span class="n">kill</span> <span class="o">-</span><span class="n">SIGKILL</span> <span class="mi">2931</span>
</pre></div>
</div>
<p>现在，让我们假设我们有一个无可救药的程序，我们想摆脱它。我们是这样做的：</p>
<ul class="simple">
<li><p>使用<code class="docutils literal notranslate"><span class="pre">ps</span></code>命令获取我们要终止的进程的进程ID（PID）。</p></li>
<li><p>为该PID发出终止命令。</p></li>
<li><p>如果进程拒绝终止（即它忽略了信号），请发送越来越苛刻的信号，直到它终止。</p></li>
</ul>
</section>
</section>
<section id="id14">
<h2>十一、比较文件<a class="headerlink" href="#id14" title="Link to this heading"></a></h2>
<p>比较文本文件（text files）是另一项有用的技能。工具通常表现为黑匣子，因此将输出文件与之前的输出文件进行比较是一项重要的调试技术。</p>
<p>在命令行中，可以使用<code class="docutils literal notranslate"><span class="pre">diff</span></code>来比较文件：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>shimofang@shimofang-virtual-machine:~/L1Q5$<span class="w"> </span>diff<span class="w"> </span>list_sorted.txt<span class="w">  </span>list.txt
10a11
&gt;<span class="w"> </span><span class="m">666666</span>
</pre></div>
</div>
<p>还可以比较目录的内容（<code class="docutils literal notranslate"><span class="pre">-q</span></code>标志将总结结果，仅显示不同文件的名称，<code class="docutils literal notranslate"><span class="pre">-r</span></code>标志将通过子目录递回）。对于<code class="docutils literal notranslate"><span class="pre">Vim</span></code>用户，有一个有用的内置<code class="docutils literal notranslate"><span class="pre">diff</span></code>工具：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vimdiff</span> <span class="n">list_sorted</span><span class="o">.</span><span class="n">txt</span>  <span class="nb">list</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="git%E4%B8%8Egh%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="btn btn-neutral float-left" title="git&amp;gh教程" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="Makefile%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="btn btn-neutral float-right" title="Makefile基础" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, YU SHI。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>